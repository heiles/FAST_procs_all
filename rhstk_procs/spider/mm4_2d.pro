pro mm4_2d, path, inputfilename, muellerparams_init, $
	indx, hb_arr, a, beamin_arr, beamout_arr, $
	muellerparams1, muellerparams_chnls, $
	plt0yes=plt0yes, plt1yes=plt1yes, ps1yes=ps1yes, $
	check=check, negate_q=negate_q, chnl=chnl, saveit=saveit, $
	m7=m7, nominal_linear=nominal_linear

;+
; PURPOSE: Generate mueller matrix elements; plot intermediate results
;if desirec. print and plot and make ps files of final results if
;desired. Replaces the old mueller4.idlprc.pro
;
;	Identical to mm4.pro, but works on the 2d beam solution instead of 
;the strip scans. the 2d solution is, in principle, more accurate
;because pointing error effects are removed.

;INPUTS:
;	INDX, the array of indices to process
;	A, BEAMOUT_ARR, the structures generated by mm0.
;
;KEYWORDS:
;
;	PLT0YES: plots intermediate results (PA dependencies on the
;screen); usually not set unless there are problems with the fit.
;
;       PLT1YES: plots final results on the screen--the PA dependencies
;plus the Mueller paramters and matrix elements.
;
;	PLT1YES: plots final results on the screen. 
;
;	PS1YES: generates ps file with final results.
;
;       CHECK: checks the calc by plotting on the screen the
;mm-corrected input data; derived MM elements should be zero. Normally
;don't bother with this; useful for pgrm development and looking into  
;problems wiht fits.
;       
;	NEGATE_Q=NEGATE_Q: multiplies uncorrected xmy by -1. always use 0.
;
;	SAVEIT: save final numerical results to disk if set
;
;	CHNL: if set, it does all the channels as well as the 
;continuum. this is done at the end. channels come 
;from beamin.stkoffsets_chnl
;
;	M7: if set, it gets the continuum using the 'M7' method. This
;means that it tries to excise interference from each spectrum. I'M NOT
;SURE THAT THE M7 OPTION WORKS VERY WELL...IT MAY NEED WORK...
;
;	BEAMIN_ARR contains all the spectral data and must be included
;if M7 is set.
;
;       NOMINAL_LINEAR: if set, forces abs(alpha) lt 45deg and adjusts
;       psi.
;
;OUTPUTS:
;	plotfiles, plots pa output files if desired.
;
;	output file with the derived results	
;
;	MUELLERPARAMS1, the output muellerparams structure.
;
;-

forward_function muellerparams_init

IF ( N_ELEMENTS( INDX) LT 4) THEN BEGIN
	print, 'SKIP MUELLER4 FOR THIS SOURCE--FEWER THAN FOUR PATTERNS'
	GOTO, SKIP
ENDIF

;GET THE NORMALIZED DATA...

if ( n_elements( negate_q) eq 0) then negate_q= 0

;STOP

IF ( KEYWORD_SET( M7)) THEN BEGIN
PRINT, 	'WE ARE NOT SET UP TO USE M7 OPTION (CUMCORR) WITH MM4_2D'
STOP
;print, 'doing m7'
make_mmlsfit_inputs_m7, indx, a, beamin_arr, beamout_arr, $
        qpa, xpy, xmy, xy, yx, $
        muellerparams_init, muellerparams0, pacoeffs, ngoodpoints, $
        mueller_az=mueller_az, negate_q=negate_q, nominal_linear=nominal_linear
ENDIF ELSE $
make_mmlsfit2d_inputs, indx, a, beamout_arr, $
        qpa, xpy, xmy, xy, yx, $
        muellerparams_init, muellerparams0, pacoeffs, ngoodpoints, $
        mueller_az=mueller_az, negate_q=negate_q, nominal_linear=nominal_linear

;stop


;PLOT THE PA DEP OF THE UNCORRECTED DATA...
;	DO IT HERE IN CASE THE MMLSFIT FAILS SO YOU CAN SEE WHAT THE
;	PROBLEM IS...
if ( plt0yes eq 1) then plot_stokespa, 0, indx, a, $
        qpa, xpy, xmy, xy, yx, $
        pacoeffs, ps=ps, title=title

IF ( NGOODPOINTS[ 0] LT 3) THEN BEGIN
	print, 'FEWER THAN 4 POINTS; RETURNING WITH NO 2D MM FIT', string(7b)
	return
ENDIF

;stop, 'mlsfit'

;DO THE LS FIT...
;stop

;stop

mmlsfit, pacoeffs, $
	muellerparams0, muellerparams1, $
	nloop, cov, $
	fixpsi=muellerparams0.fixpsi, $
	/fixchi, nominal_linear=nominal_linear

;stop

muellerparams1.freq= beamin_arr[0].cfr
muellerparams1.backend = a[0].backend
muellerparams1.sourcename= beamout_arr[0].sourcename
muellerparams1.sourceflux= beamout_arr[0].sourceflux
muellerparams1.tcalxx= beamout_arr[0].tcalxx
muellerparams1.tcalyy= beamout_arr[0].tcalyy

;STOP

;------------ PLOT, PRINT THE RESULTS IF DESIRED--------------------

;PRINT THE RESULTS ON THE TERMINAL WINDOW...
IF ( PLT1YES EQ 1) THEN BEGIN
print_stokespa, indx, a, muellerparams1, ngoodpoints, nloop
;PLOT AND PRINT THE RESULTS ON WINDOW 10
windownr=10
nrps=0
prtplot, nrps, windownr, indx, a, muellerparams1, $
        qpa, xpy, xmy, xy, yx, pacoeffs, ngoodpoints, $
        title=title
ENDIF

;MAKE THE PS PLOTFILE...
IF ( PS1YES EQ 1) THEN BEGIN
pltfilename, indx, a, inputfilename, 'm4_2d', '.ps', title, plotfilename
nrps=1
;path= '/share/heiles/newcal/testout/output/'
prtplot, nrps, windownr, indx, a, muellerparams1, $
        qpa, xpy, xmy, xy, yx, pacoeffs, ngoodpoints, $
        title=title, path=path, plotfilename=plotfilename

ENDIF

;--------------- FINISHED PLOTTING THE RESULTS ---------------


;---------------- CHECK IF DESIRED -------------------------------
;CORRECT THE INPUT DATA AND DO THE PA FIT AGAIN...
IF (CHECK NE 1) THEN GOTO, FINISHED

mm_corr_strpfit, indx, ( muellerparams1.m_tot), beamout_arr, $
	beamcorrected_arr

;NOTE THAT THE M_TOT INVERSION IS NOW DONE IN THE CORRECTION PGM, SO WE
;USE THE ABOVE STATEMENT INSTEAD OF THE ONE BELOW...
;mm_corr_strpfit, indx, invert( muellerparams1.m_tot), beamout_arr, $
;	beamcorrected_arr

;DO THE LS FIT...
make_mmlsfit_inputs, indx, a, beamcorrected_arr, $
        qpa, xpy, xmy, xy, yx, $
        muellerparams1, muellerparams1, pacoeffs, ngoodpoints, $
        mueller_az=mueller_az, negate_q=negate_q, nominal_linear=nominal_linear

;------------ BEGIN PLOTTING THE RESULTS FOR CHECKED DATA-------------
;--------------THIS IS ALWAYS DONE IF CHECK IS SET--------------------
;PLOT THE PA DEP OF THE UNCORRECTED DATA...
plot_stokespa, 1, indx, a, $
        qpa, xpy, xmy, xy, yx, $
        pacoeffs, ps=ps, title=title

mmlsfit, pacoeffs, $
	muellerparams0, muellerparams2, $
	nloop, cov, $
	fixpsi=muellerparams0.fixpsi, $
	/fixchi, nominal_linear=nominal_linear

;PLOT AND PRINT THE CHECK RESULTS ON WINDOW 10
windownr=10
nrps=0
prtplot, nrps, windownr, indx, a, muellerparams2, $
        qpa, xpy, xmy, xy, yx, pacoeffs, ngoodpoints, $
        title=title


;----------- DO CHNL-BY-CHNL FITS IF DESIRED ---------------------------
FINISHED:

nchnls= a[ indx[0]].nchnls
muellerparams_chnls= replicate( muellerparams_init(nominal_linear=nominal_linear), nchnls)

IF (KEYWORD_SET( CHNL)) THEN BEGIN

;restore, '/share/heiles/beamsav.sav'

for nrc=0, n_elements( indx)-1  do $
	beam1dfit, indx[ nrc], beamin_arr, beamout_arr, /chnls

;SAVE THE ABOVE BECAUSE IT IS SO EXPENSIVE IN COMPUTING TIME...
mm4tempname = path + 'mm4temp_' + 'bd' + string(a[ indx[0]].brd, $
	format='(i1)') + '_' + a[ indx[0]].srcname + $
	strmid( inputfilename, strpos( inputfilename, '.'))
save, beamin_arr, beamout_arr, file= mm4tempname, /VERB, /COMP

;FOR TESTING ONLY...
;restore, 'temp.sav'

tst= beamout_arr.stripfit_chnl
indxfinite= where( finite(tst, /nan) eq 1, count)
if (count ne 0) then tst[ indxfinite]=0
beamout_arr.stripfit_chnl= tst

FOR NCH= 0, NCHNLS-1 DO BEGIN
;FOR NCH= 0, 60 DO BEGIN

print, 'doing channel ', nch
;stop,  'doing channel ', nch

;GET THE NORMALIZED DATA...
make_mmlsfit_inputs, indx, a, beamout_arr, $
        qpa, xpy, xmy, xy, yx, $
        muellerparams_init, muellerparams0, pacoeffs, ngoodpoints, $
        mueller_az=mueller_az, negate_q=negate_q, chnl=nch, nominal_linear=nominal_linear

;PLOT THE PA DEP OF THE UNCORRECTED DATA...
;	DO IT HERE IN CASE THE MMLSFIT FAILS SO YOU CAN SEE WHAT THE
;	PROBLEM IS...
if ( plt0yes eq 1) then plot_stokespa, 0, indx, a, $
        qpa, xpy, xmy, xy, yx, $
        pacoeffs, ps=ps, title=title

;DO THE LS FIT...
mmlsfit, pacoeffs, $
	muellerparams0, muellerparamschnl, $
	nloop, cov, $
	fixpsi=muellerparams0.fixpsi, $
	/fixchi, nominal_linear=nominal_linear

muellerparams_chnls[ nch]= muellerparamschnl

ENDFOR

;ALWAYS PRODUCE PS PLOTS BECAUSE THIS CALCULATION IS SO EXPENSIVE...
m5plot, path, indx, a, muellerparams_chnls, /ps

;STOP
ENDIF


;----------- SAVE numerical RESULTS IN A FILE if desired ------------
IF ( KEYWORD_SET( SAVEIT)) THEN BEGIN

;path =  strmid(inputfilename, 0, strpos(inputfilename, 'mm0'))

; JUN 19, 2007...
; TIM FINDS THIS NO LONGER WORKS WITH OUR NEW NAMING CONVENTION...
;mm4name = path + 'mm4_2d_' + 'bd' + string(a[ indx[0]].brd, $
;	format='(i1)') + '_' + a[ indx[0]].srcname + $
;	strmid( inputfilename, strpos( inputfilename, '.'))
mm4name = path+'mm4_2d_'+(strsplit(plotfilename,'.ps',/REGEX,/EXTRACT))[0]+'.sav.sav'

save, indx, muellerparams1, a, beamout_arr, muellerparams_chnls, $
	filename=mm4name, /VERB, /COMP

print, ' '

print, 'MATRIX AND SOURCE INFO SAVED IN FILE '
print, mm4name

ENDIF

SKIP:

end

