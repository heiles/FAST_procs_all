<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>fitting procs</TITLE>
</head>
 
<body>
<H1>fitting procs</H1>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help</CODE>.  For more information on 
this routine, refer to the IDL Online Help Navigator 
or type: <P>
<PRE>     ? mk_html_help</PRE><P>
at the IDL command line prompt.<P>
<STRONG>Last modified: </STRONG>Tue Dec 20 11:48:25 2005.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#GET_XLEG -- TRANSFORM XIN TO OPTIMUM RANGE FOR LEGENDRE FITTING">
GET_XLEG -- TRANSFORM XIN TO OPTIMUM RANGE FOR LEGENDRE FITTING</A>
<LI><A HREF="#LEGENDREFIT -- LEGENDRE FIT USING STANDARD LEAST SQUARES">
LEGENDREFIT -- LEGENDRE FIT USING STANDARD LEAST SQUARES</A>
<LI><A HREF="#LEGENDREFIT_SVD -- LEGENDRE FIT USING STANDARD LEAST SQUARES">
LEGENDREFIT_SVD -- LEGENDRE FIT USING STANDARD LEAST SQUARES</A>
<LI><A HREF="#
LSFIT_SVD -- DO LSFIT USING SVD INSTEAD OF INVERSE NORMAL EQUATIONS.">
LSFIT_SVD -- DO LSFIT USING SVD INSTEAD OF INVERSE NORMAL EQUATIONS.</A>
<LI><A HREF="#LS_XY_3 -- FITS MULTIVARIATE SLOPES PLUS CONSTANT">
LS_XY_3 -- FITS MULTIVARIATE SLOPES PLUS CONSTANT</A>
<LI><A HREF="#POLYFIT -- POLYNOMIAL FIT USING STANDARD LEAST SQUARES">
POLYFIT -- POLYNOMIAL FIT USING STANDARD LEAST SQUARES</A>
<LI><A HREF="#POLYFIT_MEDIAN -- PERFORM A LEAST-ABS-DEV (MEDIAN) POLYNOMIAL FIT
">POLYFIT_MEDIAN -- PERFORM A LEAST-ABS-DEV (MEDIAN) POLYNOMIAL FIT</A>
<LI><A HREF="#POLYFIT_SVD -- POLYNOMIAL FIT  USING SVD.">
POLYFIT_SVD -- POLYNOMIAL FIT  USING SVD.</A>
<LI><A HREF="#POLYFIT_WGT -- POLYNOMIAL FITS OF WEIGHTED DATAPOINTS">
POLYFIT_WGT -- POLYNOMIAL FITS OF WEIGHTED DATAPOINTS</A>
<LI><A HREF="#POLY_COS_CALC">POLY_COS_CALC</A>
<LI><A HREF="#POLY_COS_FIT_SVD">POLY_COS_FIT_SVD</A>
<LI><A HREF="#POLY_FT_CALC">POLY_FT_CALC</A>
<LI><A HREF="#POLY_FT_EVAL">POLY_FT_EVAL</A>
<LI><A HREF="#POLY_FT_FIT_SVD">POLY_FT_FIT_SVD</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="GET_XLEG -- TRANSFORM XIN TO OPTIMUM RANGE FOR LEGENDRE FITTING">
<H2>GET_XLEG -- TRANSFORM XIN TO OPTIMUM RANGE FOR LEGENDRE FITTING</H2></A>
<A HREF="#LEGENDREFIT -- LEGENDRE FIT USING STANDARD LEAST SQUARES
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
GET_XLEG -- transform xin to optimum range for legendre fitting

SEE DOC IN LEGENDREFIT OR LEGENDREFIT_SVD. REPEAT THOSE IMPORTANT NOTES:
       (1) GODDARD'S FLEGENDRE IS MUCH FASTER THAN IDL'S LEGENDRE!
       (2) TO EVALUATE: YFIT= POLYLEG( XDATA, COEFFS)
       (3) PAY ATTENTION TO DOUBLE PRECISION FOR HARD PROBLEMS!!!
       (4) THE XDATA MUST LIE BETWEEN 0 AND 1. WHAT'S MORE...
       (5) IF POINTS ARE UNIFORMLY SPACED, TO OBTAIN MAX ORTHOGONALITY:
               (A) YOU HAVE nrt POINTS
               (B) THESE nrt POINTS SPAN A TOTAL RANGE range
               (C) THEN THE INTERVAL BETWEEN POINTS IS delta= range/(nrt-1)
               (D) MAKE THE INPUT X VALUES BE...

                       XLEG = (2*findgen(nrt) - (nrt-1))/nrt

                   which corresponds to half a bin away from the (-1,1) ends.
                   suppose the original nrt uniformly-spaced values have values f=frt.
                   then an alternative set of equation (good for arbitrary f) is

                       frtspan= max( frt)- min( frt)
                       dfrtspan= frtspan/( nrt-1)
                       sfrtspan= max( frt)+ min( frt)
                       XLEG = (2.*frt - sfrtspan)/(frtspan+ dfrtspan)
       OR              XLEG = (2.*f - sfrtspan)/(frtspan+ dfrtspan)

HERE, SETTING QUICK USES EQN (1) ABOVE; OTHERWISE THE SET (2) IS USED.
	USING (1) IMPLIES XIN IS UNIFORMLY SPACED, WITH QUICK=NR OF POINTS.

CALLING SEQUANCE:
	RESULT= GET_XLEG( XIN, XMIN, XMAX, DELX, [QUICK=NPTS]

INPUTS:
	XIN, the x values for which transformed valuse of XLEG are desired
	XMIN, the minimum value of X for the transformation
	XMAX, the maximum value of X for the transformation
	DELX, the interval between x values for uniformly spaced array

OPTIONAL INPUT:
	QUICK. YOU CAN SET THIS EUAL TO NR OF POINTS FOR A UNIFORMLY 
SPACED ARRAY AND NOT USE THE OTHER STANDARD INPUTS.

OUTPUT:
	XLEG, the transformed values of the inputs.  For a uniformly
spaced array containing NRT elements, the values of XLEG lie between
[-(nrt-1)/nrt] and [+(nrt-1)/nrt]

EXAMPLE:

	you have NRT=512 uniformly spaced values of frequency (FRT) and
you want to do a legendre-nomial fit.  transform the original values to
the proper range (XLEG)

		xleg= get_xleg( quick=512)

altenatively, use 
		frtmin= min(frt)
		frtmax= frt(max)
		delfrt= (frtmax- frtmin)/( nrt-1)
		xleg= get_xleg( frt, frtmin, frtmax, delfrt)

then do the fit (you should use legendrefit_svd for hard problems)...

	legendrefit, xlegfit[indxwb_incl], spwb_c[ indxwb_incl], degree, $
        coeffs, sigcoeffs, yfit, residbad= 4., problem=problem

	after doing the fit you want to apply these coefficients to an
arbiTrary set of frequencies (FRA). 

		xra= get_xleg( fra, frtmin, frtmax, delfrt)
		xrafit = polyleg( xra, coeffs)
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/get_xleg.pro)</STRONG><P>
<HR>
 
<A NAME="LEGENDREFIT -- LEGENDRE FIT USING STANDARD LEAST SQUARES">
<H2>LEGENDREFIT -- LEGENDRE FIT USING STANDARD LEAST SQUARES</H2></A>
<A HREF="#GET_XLEG -- TRANSFORM XIN TO OPTIMUM RANGE FOR LEGENDRE FITTING
">[Previous Routine]</A>
<A HREF="#LEGENDREFIT_SVD -- LEGENDRE FIT USING STANDARD LEAST SQUARES
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
LEGENDREFIT -- legendre fit using standard least squares

IMPORTANT NOTES: 
	(1) GODDARD'S FLEGENDRE IS MUCH FASTER THAN IDL'S LEGENDRE!
	(2) TO EVALUATE: YFIT= POLYLEG( XDATA, COEFFS)
       (3) PAY ATTENTION TO DOUBLE PRECISION FOR HARD PROBLEMS!!!
       (4) THE XDATA MUST LIE BETWEEN 0 AND 1. WHAT'S MORE...
       (5) IF POINTS ARE UNIFORMLY SPACED, TO OBTAIN MAX ORTHOGONALITY:
               (A) YOU HAVE nrt POINTS
               (B) THESE nrt POINTS SPAN A TOTAL RANGE range
               (C) THEN THE INTERVAL BETWEEN POINTS IS delta= range/(nrt-1)
               (D) MAKE THE INPUT X VALUES BE...

                       X = (2*findgen(nrt) - (nrt-1))/nrt

                   which corresponds to half a bin away from the (-1,1) ends.
                   suppose the original nrt uniformly-spaced values have values f=frt.
                   then an alternative set of equation (good for arbitrary f) is

                       frtspan= max( frt)- min( frt)
                       dfrtspan= frtspan/( nrt-1)
                       sfrtspan= max( frt)+ min( frt)
                       x = (2.*frt - sfrtspan)/(frtspan+ dfrtspan)
       OR              x = (2.*f - sfrtspan)/(frtspan+ dfrtspan)

TIME:
       (1) LEGENDRE FIT IS ABOUT 20% SLOWER THAN POLYNOMIAL FIT.
       (2) FOR BOTH, SVD VERSION IS ABOUT 3 TIMES SLOWER THAN ORDINARY VERSION.

PURPOSE:
    like a polynomial fit but uses legendre functions, which are 
orthogonal over the interval (-1,1). the input data must be 
within this range.

CALLING SEQUENCE:
    LEGENDREFIT, xdata, ydata, degree, coeffs, sigcoeffs, yfit, $
	sigma, nr3bad, cov

INPUTS:
     xdata: the x-axis data points. 
     ydata: the y-axis data points.
     degree: the degree of the legendre fit. e.g. linear fit has degree=1.
KEYWORDS:
     residbad: if set, excludes points those residuals exceed residbad*sigma
	goodindx: the array of indices actually used in the fit.
	problem: nonzero if there was a problem with the fit.
OUTPUTS:
     coeffs: array of coefficients.
     sigcoeffs: me's of the coefficients.
     yfit: the fitted points evaluated at datax.
     sigma: the sigma (mean error) of the data points.
     nr3sig: the nr of datapoints lying more than 3 sigma away from the fit.
     ncov: the normalized covariance matrix.
     cov: the covariance matrix.

HISTORY;
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/legendrefit.pro)</STRONG><P>
<HR>
 
<A NAME="LEGENDREFIT_SVD -- LEGENDRE FIT USING STANDARD LEAST SQUARES">
<H2>LEGENDREFIT_SVD -- LEGENDRE FIT USING STANDARD LEAST SQUARES</H2></A>
<A HREF="#LEGENDREFIT -- LEGENDRE FIT USING STANDARD LEAST SQUARES
">[Previous Routine]</A>
<A HREF="#LSFIT_SVD -- DO LSFIT USING SVD INSTEAD OF INVERSE NORMAL EQUATIONS.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
LEGENDREFIT_SVD -- legendre fit using standard least squares

IMPORTANT NOTES:
       (1) GODDARD'S FLEGENDRE IS MUCH FASTER THAN IDL'S LEGENDRE!
       (2) TO EVALUATE: YFIT= POLYLEG( XDATA, COEFFS)
	(3) PAY ATTENTION TO DOUBLE PRECISION FOR HARD PROBLEMS!!!
	(4) THE XDATA MUST LIE BETWEEN 0 AND 1. WHAT'S MORE...
	(5) IF POINTS ARE UNIFORMLY SPACED, TO OBTAIN MAX ORTHOGONALITY:
		(A) YOU HAVE nrt POINTS
		(B) THESE nrt POINTS SPAN A TOTAL RANGE range
		(C) THEN THE INTERVAL BETWEEN POINTS IS delta= range/(nrt-1)
		(D) MAKE THE INPUT X VALUES BE...

			X = (2*findgen(nrt) - (nrt-1))/nrt

		    which corresponds to half a bin away from the (-1,1) ends.
		    suppose the original nrt uniformly-spaced values have values f=frt.
		    then an alternative set of equation (good for arbitrary f) is

			frtspan= max( frt)- min( frt)
			dfrtspan= frtspan/( nrt-1)
			sfrtspan= max( frt)+ min( frt)
			x = (2.*frt - sfrtspan)/(frtspan+ dfrtspan)
	OR		x = (2.*f - sfrtspan)/(frtspan+ dfrtspan)

TIME: 
	(1) LEGENDRE FIT IS ABOUT 20% SLOWER THAN POLYNOMIAL FIT.
	(2) FOR BOTH, SVD VERSION IS ABOUT 3 TIMES SLOWER THAN ORDINARY VERSION.

PURPOSE:
    like a SVD polynomial fit but uses legendre functions, which are 
orthogonal over the interval (-1,1). the input data must be 
within this range.

CALLING SEQUENCE:
    LEGENDREYFIT_SVD, xdata, ydata, degree, coeffs, sigcoeffs, yfit, $
	sigma, nr3bad, cov

INPUTS:
     xdata: the x-axis data points. 
     ydata: the y-axis data points.
     degree: the degree of the legendre fit. e.g. linear fit has degree=1.
KEYWORDS:
     residbad: if set, excludes points those residuals exceed residbad*sigma
	goodindx: the array of indices actually used in the fit.
	problem: nonzero if there was a problem with the fit.
OUTPUTS:
     coeffs: array of coefficients.
     sigcoeffs: me's of the coefficients.
     yfit: the fitted points evaluated at datax.
     sigma: the sigma (mean error) of the data points.
     nr3sig: the nr of datapoints lying more than 3 sigma away from the fit.
     ncov: the normalized covariance matrix.
     cov: the covariance matrix.

HISTORY;
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/legendrefit_svd.pro)</STRONG><P>
<HR>
 
<A NAME="LSFIT_SVD -- DO LSFIT USING SVD INSTEAD OF INVERSE NORMAL EQUATIONS.">
<H2>LSFIT_SVD -- DO LSFIT USING SVD INSTEAD OF INVERSE NORMAL EQUATIONS.
</H2></A>
<A HREF="#LEGENDREFIT_SVD -- LEGENDRE FIT USING STANDARD LEAST SQUARES
">[Previous Routine]</A>
<A HREF="#LS_XY_3 -- FITS MULTIVARIATE SLOPES PLUS CONSTANT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
LSFIT_SVD -- do lsfit using SVD instead of inverse normal equations.

	The equations of condition are

	X a = y

where X is a the equation-of-conditon matrix, A is the vector of unknowns,
and y are the measured values.

	This returns the solution vector x, its variances and sigmas,
and the normalizedd covariance matrix. These are the standard ls fit things.
It also returns the vector of SVD weights and the V matrix (see NM section
2.6 ('SVD of a Square Matrix') and chapter 15 (least squares solution by SVD).

CALLING SEQUENCE:
lsfit_svd, X, y, U, V, $
	wgt, a, vara, siga, ncov, s_sq, $
	xxinv_svd=xxinv_svd, wgt_inv=wgt_inv, ybar=ybar, cov=cov

INPUTS:
	X, the equation-of-conditon matrix
	y, the vector of measured values
	U, NM's matrix U (input only if WGT_INV is used; see discussion below)
	V, NM's matrix V (input only if WGT_INV is used; see discussion below)

OUTPUTS:
	U, NM's U matrix. also an input; see discussion below
	V, NM's V matrix, the matrix whose columns are the 
orthonormal eigenvectors. also an input; see discussion below
	WGT, the vector of weights of V (see discussion below)
	A, the vector of unknowns
	vara, a vector containing the variance of a
	siga, a vector containing the sigma of a (sqrt variance)
	ncov, the normalized covariance matrix
	s_sq, the variance of the datapoints

KEYWORDS:
	WGT_INV, the vector of reciprocal weights (equal to 1/WGT unless you
change them yourself). If WGT_INV is specified, then the procedure assumes
that  you have already run it once, examined the weight vector WGT and
found a problem, and specified the new vector of WGT_INV=1/WGT. It uses this
modified WGT_INV and it uses the values of U and V given as inputs
(because they have already been computed). If WGT_INV is not specified, it
evaluates U and V and returns them as outputs.
See COMMENTARIES below.

	XXINV_SVD, the effective inverse of X obtained using WGT_INV. 
If WGT_INV is left unmodified, XXINV_SVD is the inverse of X. But the
whole point of SVD is to modify WGT_INV by setting certain elements to 
zero so a to eliminate an effectively degenerate inverse of X. 
See COMMENTARIES below.

	COV, the usual covariance matrix

	YBAR, the fitted values of the datapoints

IMPORTANT COMMENTARIES REGARDING USE OF SVD!!!
	Read NM's discussion of WGT. Each element of WGT refers to the 
corresponding column of V; consider each column of V to be an eigenvector
in the space defined by the X matrix. 
If a particular value of WGT is small, then the projection of the
corresponding eigenvector in V is small. 

	As discussed in NM, you should then rerun the solution with the 
corresponding elements of WGT_INV set equal to 1/WGT, except for the problem 
value which should be set equal to zero (yes, if a particular element of
WGT is small the corresponding WGT_INV element is large; you set it equal to
zero to remove it from the solution).

HISTORY: written by carl heiles while flying back from Arecibo in july 2004.
mistakes in covariance matrix and associated parameter errors 27 feb 05.
	29jun05: replace SVDC (which doesn't always converge) 
with LA_SVD (needs idl 5.6)
	23aug05: use !version to choose svd routine. warn if svdc.
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/lsfit_svd.pro)</STRONG><P>
<HR>
 
<A NAME="LS_XY_3 -- FITS MULTIVARIATE SLOPES PLUS CONSTANT">
<H2>LS_XY_3 -- FITS MULTIVARIATE SLOPES PLUS CONSTANT</H2></A>
<A HREF="#LSFIT_SVD -- DO LSFIT USING SVD INSTEAD OF INVERSE NORMAL EQUATIONS.
">[Previous Routine]</A>
<A HREF="#POLYFIT -- POLYNOMIAL FIT USING STANDARD LEAST SQUARES
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME: 
LS_XY_3 -- FITS MULTIVARIATE SLOPES PLUS CONSTANT

PURPOSE: FITS MULTIVARIATE SLOPES PLUS CONSTANT, E.G.
	ZZ = A0*U + A1*V + a2*W +...

assumes U, V, W... are the independent variables (or functions of 
independent variables)


************************* CAVAET ******************************
tests by my ay250 class in 2005 indicate that the variances of 
derived parameters may not be correct. however, there appears to
be no bias in the derived parameters.
****************************************************************

INPUTS:
	XXIN, the X matrix of the independent variables, of the form...
		 _                  _
		| u_0   v_0   w_0  ... |
		| u_1   v_1   w_1  ... |
		| u_2   v_2   w_2  ... |
		| ...   ...   ...  ... |
		|_                    _|

	SIGMAXX, the intrinsic sigmas (uncertainties) of the U, V values, 
	in which ONE of the independent variables can have nonzero errors.
	This makes SIGMAXX to be of the form...

		 _                       _
		| sig(u_0)    0    0  ... |
		| sig(u_0)    0    0  ... |
		| sig(u_0)    0    0  ... |
		|  ...       ...  ... ... |
		|_                       _|

	ZZIN, a 'horizontal' vector of the ZZ measurements
	SIGMAZZ, the intrinsic measurement errors (sigmas) of the ZZ values.

KEYWORDS:
	TOLERANCE, the maximum change in any derived parameter. 
	default is 1e-3
OUTPUTS:
	A_LS, the vector of results for the 'conventional' ls fit 
		(the one that assumes no errors in U,  V...
	ATRY, the vector of results for the ls fit
	CHISQ, the chisq of the fit
	CHISQ_REDUCED, the reduced chisq of the fit
	SIGSQA, the sigma-squared of ATRY
	ZZBAR, the predicted z-values from the derived ls parameters

COMMENTS, RESTRICTIONS: See lsfit2005 writeup. max nr iterations is
nr_iterate_max, currently set for max of 100.

chisq definition is questionable (divided by
	number of variables).

	I'm not sure about the exact value of chisq...seems to be off 
	(too small) by a little bit.

HISTORY: 10 June 2002 by Carl Heiles
updated mar2004...extraneous stuff removed and documentation firmed up.
	tested only one a single independent variable.
updated feb2005...more testing, realized errors can exist only for one
	independent variable. For more generasl solns see Jefferys AJ 85, 177.
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/ls_xy_3.pro)</STRONG><P>
<HR>
 
<A NAME="POLYFIT -- POLYNOMIAL FIT USING STANDARD LEAST SQUARES">
<H2>POLYFIT -- POLYNOMIAL FIT USING STANDARD LEAST SQUARES</H2></A>
<A HREF="#LS_XY_3 -- FITS MULTIVARIATE SLOPES PLUS CONSTANT
">[Previous Routine]</A>
<A HREF="#POLYFIT_MEDIAN -- PERFORM A LEAST-ABS-DEV (MEDIAN) POLYNOMIAL FIT
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
POLYFIT -- polynomial fit using standard least squares

PURPOSE:
    Polynomial fits, like IDL's POLY_FIT, but returns sigmas of
	the coefficients, the fitted line, and the normalized covariance
	matrix also.

CALLING SEQUENCE:
    POLYFIT, xdata, ydata, degree, coeffs, sigcoeffs, yfit, sigma, nr3bad, cov

INPUTS:
     xdata: the x-axis data points. 
     ydata: the y-axis data points.
     degree: the degree of the polynomial. e.g. linear fit has degree=1.
KEYWORDS:
     residbad: if set, excludes points those residuals exceed residbad*sigma
	goodindx: the array of indices actually used in the fit.
	problem: nonzero if there was a problem with the fit.
OUTPUTS:
     coeffs: array of coefficients.
     sigcoeffs: me's of the coefficients.
     yfit: the fitted points evaluated at datax.
     sigma: the sigma (mean error) of the data points.
     nr3sig: the nr of datapoints lying more than 3 sigma away from the fit.
     ncov: the normalized covariance matrix.
     cov: the covariance matrix.

HISTORY;
	30 sep i tested to see if la_invert is better than invert.
there is no essential diff, so we stick with invert.
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/polyfit.pro)</STRONG><P>
<HR>
 
<A NAME="POLYFIT_MEDIAN -- PERFORM A LEAST-ABS-DEV (MEDIAN) POLYNOMIAL FIT">
<H2>POLYFIT_MEDIAN -- PERFORM A LEAST-ABS-DEV (MEDIAN) POLYNOMIAL FIT</H2></A>
<A HREF="#POLYFIT -- POLYNOMIAL FIT USING STANDARD LEAST SQUARES
">[Previous Routine]</A>
<A HREF="#POLYFIT_SVD -- POLYNOMIAL FIT  USING SVD.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
   POLYFIT_MEDIAN -- perform a least-abs-dev (median) polynomial fit

PURPOSE:
    Polynomial MEDIAN fits.

CALLING SEQUENCE:
    POLYFIT_MEDIAN, xdata, ydata, degree, $
	coeffs, sigcoeffs, yfit, sigma, ncov

INPUTS:
     XDATA: the x-axis data points. 
     YDATA: the y-axis data points.
     DEGREE: the degree of the polynomial. e.g. linear fit has degree=1.

OUTPUTS:
     COEFFS: array of coefficients.
     SIGCOEFFS: me's of the coefficients. SEE NOTE BELOW
     YFIT: the fitted points evaluated at datax.
     SIGMA: the sigma (mean error) of the data points. SEE NOTE BELOW
     NCOV: the normalized covariance matrix.

NOTE ON SIGMA AND SIGCOEFFS:
	SIGMA and SIGCOEFFS are calculated as if we were doing a least
squares fit.  this is appropriate for Gaussian statistics, but not for
others, so this is relatively meaningless. For example, a single large
discrepant point will contribute a lot to sigma, and to sigcoeffs, but
because this is a median fit it is ignored.

</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/polyfit_median.pro)</STRONG><P>
<HR>
 
<A NAME="POLYFIT_SVD -- POLYNOMIAL FIT  USING SVD.">
<H2>POLYFIT_SVD -- POLYNOMIAL FIT  USING SVD.</H2></A>
<A HREF="#POLYFIT_MEDIAN -- PERFORM A LEAST-ABS-DEV (MEDIAN) POLYNOMIAL FIT
">[Previous Routine]</A>
<A HREF="#POLYFIT_WGT -- POLYNOMIAL FITS OF WEIGHTED DATAPOINTS
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
   POLYFIT_SVD -- polynomial fit  using SVD.

PURPOSE:
    Polynomial fits USING SVD. like IDL's POLY_FIT and my POLYFIT, 
	but uses SVD. POLYFIT is less accurrate thaN POLY_FIT, which
	in turn is less accurate than POLYFIT_SVD. Returns sigmas of
	the coefficients, the fitted line, and the normalized covariance
	matrix also.

TIME: SVD VERSION IS ABOUT 3 TIMES SLOWER THAN ORDINARY VERSION.

   Has an option to exclude points whose residuals exceed RESIDBAD.

CALLING SEQUENCE:
    POLYFIT_SVD, xdata, ydata, degree, $
	coeffs, sigcoeffs, yfit, sigma, nr3bad, ncov, cov, 
	[residbad], [goodindx], [problem], $
	wgts=wgts, u=u, wgt_inv=wgt_inv, v=v, auto=auto
INPUTS:
     XDATA: the x-axis data points. 
     YDATA: the y-axis data points.
     DEGREE: the degree of the polynomial. e.g. linear fit has degree=1.
KEYWORDS:
     RESIDBAD: if set, excludes points those residuals exceed residbad*sigma
	GOODINDX, the indices of the points included in the fit
       PROBLEM: nonzero if a problem. -2 means too many points discarded
	WGTS, the svd weights.
	WGT_INV: you can modify these to eliminate degeneracies; see
documentation for LSFIT_SVD 
	U, the returned U matrix from LSIT_SVD
	V, the returned V matrix from LSIT_SVD
	AUTO: if nonzero, does the WGT_INV business automatically, zeroing the
inverse weights when the ratio is smaller than AUTO. if AUTO is set equal
to >= one, it defaults to 1e-12

OUTPUTS:
     COEFFS: array of coefficients.
     SIGCOEFFS: me's of the coefficients.
     YFIT: the fitted points evaluated at datax.
     SIGMA: the sigma (mean error) of the data points.
     NR3SIG: the nr of datapoints lying more than 3 sigma away from the fit.
     NCOV: the normalized covariance matrix.
     COV: the covariance matrix.

HOW TO USE YOUR OWN WGT_INV: (it's easier to use AUTO keyword!)

	first invoke this procedure. it returns the native WGTS and
WGT_INV, and also the U and V as optional outputs. 
	then modify WGT_INV and call this proc again using the 
modified WGT_INV, U and V as optional inputs

suppose WGTS spans a huge range, say 10^20. do something like...
	indx= where( wgts/max( wgts) lt 1e-12)
	wgt_inv= 1./wgts
	wgt_inv[ indx]= 0.
and then call this proc again, specifying U, V, and WGT_INV as optional inputs.

</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/polyfit_svd.pro)</STRONG><P>
<HR>
 
<A NAME="POLYFIT_WGT -- POLYNOMIAL FITS OF WEIGHTED DATAPOINTS">
<H2>POLYFIT_WGT -- POLYNOMIAL FITS OF WEIGHTED DATAPOINTS</H2></A>
<A HREF="#POLYFIT_SVD -- POLYNOMIAL FIT  USING SVD.">[Previous Routine]</A>
<A HREF="#POLY_COS_CALC">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
POLYFIT_WGT -- polynomial fits of weighted datapoints

PURPOSE:
    Polynomial fits, like IDL's POLY_FIT, but allows weighting the input eq's of cond.
	returns sigmas of
	the coefficients, the fitted line, and the normalized covariance
	matrix also.

CALLING SEQUENCE:
    POLYFIT_WGT, xdata, ydata, wgts, degree, coeffs, sigcoeffs, yfit, sigma, nr3bad, cov

INPUTS:
     xdata: the x-axis data points. 
     ydata: the y-axis data points.
	wgts, the weighting factors applied to eqns of cond. these get squared
		then the normal equations are calculated.
     degree: the degree of the polynomial. e.g. linear fit has degree=1.
KEYWORDS:
     residbad: if set, excludes points those residuals exceed residbad*sigma
	goodindx: the array of indices actually used in the fit.
	problem: nonzero if there was a problem with the fit.
OUTPUTS:
     coeffs: array of coefficients.
     sigcoeffs: me's of the coefficients.
     yfit: the fitted points evaluated at datax.
     sigma: the sigma (mean error) of the data points.
     nr3sig: the nr of datapoints lying more than 3 sigma away from the fit.
     ncov: the normalized covariance matrix.
     cov: the covariance matrix.

IMPORTANT COMMENT: i have not checked whether the returned errors are right, nor whether it 
behaves properly when eliminating bad points.
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/polyfit_wgt.pro)</STRONG><P>
<HR>
 
<A NAME="POLY_COS_CALC">
<H2>POLY_COS_CALC</H2></A>
<A HREF="#POLYFIT_WGT -- POLYNOMIAL FITS OF WEIGHTED DATAPOINTS
">[Previous Routine]</A>
<A HREF="#POLY_COS_FIT_SVD">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
PURPOSE: calculate the fits generated ty poly_cos_fit_svd for any set of frequencies.
INPUTS:
	POLYCOEFFS, the array of polynomial coefficients
	TIMES, the times at which the fourier coeffs coscoeffs are evaluated
	coscoeffs, the array of fourier coefficients
	FRQS, the freq arraay for which  you want result;

RETURNS: the calculated fitted spectrum.

OUTPUTS:
	res_poly, the polynomial portion of the fit
	res_cos, the fourier portion of the fit
	cospower, the fourier power versus time
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/poly_cos_calc.pro)</STRONG><P>
<HR>
 
<A NAME="POLY_COS_FIT_SVD">
<H2>POLY_COS_FIT_SVD</H2></A>
<A HREF="#POLY_COS_CALC">[Previous Routine]</A>
<A HREF="#POLY_FT_CALC">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
POLY_FT_FIT -- fit polynomial plus cosine terms to a spectrum.

CALLING SEQUENCE: 
POLY_FT_FIT, frqin, ydata, degree, times, $
	coeffs, sigcoeffs, yfit, sigma, nr3bad, ncov, cov, $
	residbad=residbad, goodindx=goodindx, problem=problem, $
        polycoeffs=polycoeffs, coscoeffs=coscoeffs, cospower=cospower, $
	yfit_poly= yfit_poly, yfit_cos=yfit_cos

INPUTS:
	FRQIN, the array of input freqs for the spectrum
	YDATA, the array of spectral points
	DEGREE, the degree of the polynomial to fit
	TIMES, the times for whichi the fourier components are fitted

OUTPUTS:
	COEFFS, the array of fitted coefficients. the first (degree+1)
coefficients are for the polynomial; the remaining ones are for the
cosines, the numbver of which is equal to the nr of elements in times. 
	SIGCOEFFS, sigmas of coeffs
	YFIT, the fitted datapoints
	SIGMA, the sigma of the fitted points
	NR3BAD, the nr of bad points on the last iteration. should be zero.
	NCOV, the normalized covariance matrix
	COV, the covariance matrix

OPTIONALS:
	RESIDBAD: toss out points that depart by more that this times sigma.
e.g., if residbad is 3, it eliminates points haveing resids gt 3 sigma
	GOODINDX, the indx of good points (the points that it actually 
included in the fit)
	PROBLEM, nonzero if there is a problem
	POLYCOEFFS, the set of coeffs in the polynomial fit
	COSCOEFFS, the set of coeffs for the cosines
	SIGCOSCOEFFS, sigmas of coscoeffs
	COSPOWER, the power in each cosine component (square of coefficient)
	SIGCOSPOWER, the power in each cosine component (square of coefficient)
	YFIT_POLY, THE fitted polynomial curve
	YFIT_COS, THE fitted cosine curve
	ITMAX, the max nr of iterations in svdc.
	NOTE: yfit= yfit_poly+ yfit_cosine

EXAMPLE OF USE:
	you've got a lousy ripple in the spectrum. the ripple is represented
by yfit_cos. ydata-yfit_cos is the ripple-free spectrum.

HISTORY: carl h, 11june2005, adapted from poly_ft_fit_svd
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/poly_cos_fit_svd.pro)</STRONG><P>
<HR>
 
<A NAME="POLY_FT_CALC">
<H2>POLY_FT_CALC</H2></A>
<A HREF="#POLY_COS_FIT_SVD">[Previous Routine]</A>
<A HREF="#POLY_FT_EVAL">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
PURPOSE: calculate the fits generated ty poly_ft_fit_svd for any set of frequencies.
INPUTS:
	POLYCOEFFS, the array of polynomial coefficients
	TIMES, the times at which the fourier coeffs FCOEFFS are evaluated
	FCOEFFS, the array of fourier coefficients
	FRQS, the freq arraay for which  you want result;

RETURNS: the calculated fitted spectrum.

OUTPUTS:
	res_poly, the polynomial portion of the fit
	res_f, the fourier portion of the fit
	fpower, the fourier power versus time
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/poly_ft_calc.pro)</STRONG><P>
<HR>
 
<A NAME="POLY_FT_EVAL">
<H2>POLY_FT_EVAL</H2></A>
<A HREF="#POLY_FT_CALC">[Previous Routine]</A>
<A HREF="#POLY_FT_FIT_SVD">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
POLY_FT_EVAL -- using results from poly_ft_fit, calculate the fitted spectrum 

CALLING SEQUENCE: 
poly_ft_eval, frqin, degree, times, coeffs, sigcoeffs, $
	yeval, yeval_poly, yeval_fourier

INPUTS:
	FRQIN, the array of input freqs at which to evaluate the spectrum
	DEGREE, the degree of the polynomial to fit
	COEFFS, the set of coeffs from the original fit
	TIMES, the times for whichi the fourier components are fitted

OUTPUTS:
	YEVAL, the evaluated points
	YEVAL_POLY, the contribution to YEVAL from the polynomial part
	YEVAL_FOURIER, the contribution to YEVAL from the fourier part

HISTORY: carl h, 02sep2005
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/poly_ft_eval.pro)</STRONG><P>
<HR>
 
<A NAME="POLY_FT_FIT_SVD">
<H2>POLY_FT_FIT_SVD</H2></A>
<A HREF="#POLY_FT_EVAL">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
POLY_FT_FIT -- fit polynomial plus fourier terms to a spectrum.

CALLING SEQUENCE: 
POLY_FT_FIT, frqin, ydata, degree, times, $
	coeffs, sigcoeffs, yfit, sigma, nr3bad, ncov, cov, $
	residbad=residbad, goodindx=goodindx, problem=problem, $
        polycoeffs=polycoeffs, fcoeffs=fcoeffs, fpower=fpower, $
	yfit_poly= yfit_poly, yfit_fourier=yfit_fourier

INPUTS:
	FRQIN, the array of input freqs for the spectrum
	YDATA, the array of spectral points
	DEGREE, the degree of the polynomial to fit
	TIMES, the times for whichi the fourier components are fitted

OUTPUTS:
	COEFFS, the array of fitted coefficients. the first (degree+1)
coefficients are for the polynomial; the remaining ones are paired,
the number of pairs is equal to the nr of elements in times. the first
member of each pair is the cosine term, the second the sine.
	YFIT, the fitted datapoints
	SIGMA, the sigma of the fitted points
	NR3BAD, the nr of bad points on the last iteration. should be zero.
	NCOV, the normalized covariance matrix
	COV, the covariance matrix

OPTIONALS:
	RESIDBAD: toss out points that depart by more that this times sigma.
e.g., if residbad is 3, it eliminates points haveing resids gt 3 sigma
	GOODINDX, the indx of good points (the points that it actually 
included in the fit)
	PROBLEM, nonzero if there is a problem
	POLYCOEFFS, the set of coeffs in the polynomial fit
	FCOEFFS, the set of coeffs that are fourier pairs
	FPOWER, the power in each fourier component (quad sum of cos and sin)
	YFIT_POLY, THE fitted polynomial curve
	YFIT_FOURIER, THE fitted fourier curve
	ITMAX, the max nr of iterations in svdc.
	NOTE: yfit= yfit_poly_ yfit_fourier

EXAMPLE OF USE:
	you've got a lousy ripple in the spectrum. the ripple is represented
by yfit_fourier. ydata-yfit_fourier is the ripple-free spectrum.

HISTORY: carl h, 24june2005
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/fitting/poly_ft_fit_svd.pro)</STRONG><P>
<HR>
 
</body>
</html>
