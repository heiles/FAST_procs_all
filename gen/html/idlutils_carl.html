<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>idlutils_carl procs</TITLE>
</head>
 
<body>
<H1>idlutils_carl procs</H1>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help</CODE>.  For more information on 
this routine, refer to the IDL Online Help Navigator 
or type: <P>
<PRE>     ? mk_html_help</PRE><P>
at the IDL command line prompt.<P>
<STRONG>Last modified: </STRONG>Tue Dec 20 11:48:26 2005.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#BAR">BAR</A>
<LI><A HREF="#COUNT">COUNT</A>
<LI><A HREF="#FILLARR --  GENERATE AN ARRAY FROM MIN TO MAX WITH STEP SIZE DEL.
">FILLARR --  GENERATE AN ARRAY FROM MIN TO MAX WITH STEP SIZE DEL.</A>
<LI><A HREF="#
INDXTODIMS --  CONVERT BETWEEN A 1-D INDEX AND AN N-DIMENSIONAL INDEX OR VICE-VERSA
">
INDXTODIMS --  CONVERT BETWEEN A 1-D INDEX AND AN N-DIMENSIONAL INDEX OR VICE-VERSA
</A>
<LI><A HREF="#LOOP_BAR">LOOP_BAR</A>
<LI><A HREF="#MAKEARR -- GENERATE AN N-EL ARRAY RUNNING FROM VALUES MIN TO MAX">
MAKEARR -- GENERATE AN N-EL ARRAY RUNNING FROM VALUES MIN TO MAX</A>
<LI><A HREF="#
RDPLOT (TR_RDPLOT) -- LIKE CURSOR BUT WITH FULL-SCREEN CURSOR AND CONTINUOUS READOUT.
">
RDPLOT (TR_RDPLOT) -- LIKE CURSOR BUT WITH FULL-SCREEN CURSOR AND CONTINUOUS READOUT.
</A>
<LI><A HREF="#SHOWFONT -- DISPLAY VECTOR-DRAWN FONTS">
SHOWFONT -- DISPLAY VECTOR-DRAWN FONTS</A>
<LI><A HREF="#TRC">TRC</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="BAR">
<H2>BAR</H2></A>
<A HREF="#COUNT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>

 A program to create a progress bar within a loop.

 Call sequence:
   BAR, I, IMAX

 Inputs:
   I - The index being advanced in the loop.
   IMAX - The value at the loop's finish.

 Outputs:
   Prints out a simple empty bar that fills up with 10 dashes as the
   loop completes.

 Calls:
   DELVARX (Goddard Routine)

Katie Peek August 2004
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/idlutils_carl/bar.pro)</STRONG><P>
<HR>
 
<A NAME="COUNT">
<H2>COUNT</H2></A>
<A HREF="#BAR">[Previous Routine]</A>
<A HREF="#FILLARR --  GENERATE AN ARRAY FROM MIN TO MAX WITH STEP SIZE DEL.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME
COUNT -- This procedure exists only as example of overwriting the screen in place
with a running number without skipping lines.
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/idlutils_carl/count.pro)</STRONG><P>
<HR>
 
<A NAME="FILLARR --  GENERATE AN ARRAY FROM MIN TO MAX WITH STEP SIZE DEL.">
<H2>FILLARR --  GENERATE AN ARRAY FROM MIN TO MAX WITH STEP SIZE DEL.</H2></A>
<A HREF="#COUNT">[Previous Routine]</A>
<A HREF="#
INDXTODIMS --  CONVERT BETWEEN A 1-D INDEX AND AN N-DIMENSIONAL INDEX OR VICE-VERSA
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME: 
FILLARR --  generate an array from MIN to MAX with step size DEL. 


 PURPOSE:
       This function generates an array from MIN to MAX with
       step size DEL. If an integer number of steps cannot be
       fit between MIN and MAX, then MAX will be adjusted to
       be as close as the specified maximum as possible.
 CATEGORY:



 CALLING SEQUENCE:
       f = fillarr(n, min, max [,fan=, transfan=, /double])


 INPUTS:

       DEL:  The desired step size
       MIN:  The value of the first array element in F
       MAX:  The value of the last array element in F if
             (MAX-MIN)/DEL is an integer. Adjusted otherwise.

 OPTIONAL INPUTS:

 KEYWORD PARAMETERS:

       FAN:        Number of times the array is to be repeated.
                   The final dimensions of F  will be 
                   fix((MAX-MIN)/DEL) + 1 columns by FAN rows.

       /TRANSPOSE  Final dimensions of F wil be FAN columns by 
                   fix((MAX-MIN)/DEL) + 1 rows if FAN is specified. 

 OUTPUTS:

       F:    Final array. If input parameters are double precision,
             then F will be double as well. F is float otherwise.


 OPTIONAL OUTPUTS:



 COMMON BLOCKS:



 SIDE EFFECTS:



 RESTRICTIONS:



 PROCEDURE:



 EXAMPLE:

         For an array that runs from 2 to 5 in steps of .7

         IDL> f = fillarr(.7,2,5)
         IDL> print, f
            2.00000      2.70000      3.40000     4.10000    4.80000
         
 MODIFICATION HISTORY:
 Written by John "JohnJohn" Johnson 21-Feb-2002
 22-Feb-2002 JohnJohn- Fixed precision bug
 23-Feb-2002 JohnJohn- Calculations performed in double precision. 
                       Output in double precision if input is 
                       double.
 01-Mar-2002 JohnJohn- Much props to Tim Robishaw (Tdogg) for helping
                       me understand machine precision and truly fix
                       the precision bug.
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/idlutils_carl/fillarr.pro)</STRONG><P>
<HR>
 
<A NAME="
INDXTODIMS --  CONVERT BETWEEN A 1-D INDEX AND AN N-DIMENSIONAL INDEX OR VICE-VERSA
">
<H2>
INDXTODIMS --  CONVERT BETWEEN A 1-D INDEX AND AN N-DIMENSIONAL INDEX OR VICE-VERSA
</H2></A>
<A HREF="#FILLARR --  GENERATE AN ARRAY FROM MIN TO MAX WITH STEP SIZE DEL.
">[Previous Routine]</A>
<A HREF="#LOOP_BAR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
INDXTODIMS --  convert between a 1-d index and an n-dimensional index or vice-versa

PURPOSE:
    converts between a 1-d index and an n-dimensional index for an
	array of the given size. Goes either direction.

CALLING SEQUENCE:
	INDXTODIMS, array, indx, dims, direction

INPUTS:
	array: an N-dimensional input array. Not changed or used except
to define the dimensions for which the outputs are computed.
	indx: the one-d index. an INPUT if direction=+1, an OUTPUT otherwise.
	dims: a vector of size N containing the three indices in N-d space.
An INPUT if direction=-1, an OUTPUT otherwise.
	direction: the direction of conversion: 
		+1 to go from INDX ---> DIMS
		-1 to go from DIMS ---> INDX

IMPORTANT: INDX can be an N-element array, where N is the nr of indices
		to treat.
	    DIMS can be an N by M element array, where N is the nr of indices
		to treat and M is the nr of dimensions in ARRAY.
OUTPUTS:
	indx: the one-d index. an INPUT if direction=+1, an OUTPUT otherwise.
If indx is an INPUT, it may be a 1-d array, in which case dims will
be an array whose first dimension is that of indx.
	dims: a vector of size N containing the three indices in N-d space.
An INPUT if direction=-1, an OUTPUT otherwise.

EXAMPLE:
	you have a 3-d vector X(541,541,9) and a 1-d index returned from
the 'where' function equal to 880212.

	INDXTODIMS, X, 880212, dims, +1

returns dims=[5,4,3].
HISTORY:
	Written by Carl Heiles. 18 Sep 1998.
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/idlutils_carl/indxtodims.pro)</STRONG><P>
<HR>
 
<A NAME="LOOP_BAR">
<H2>LOOP_BAR</H2></A>
<A HREF="#
INDXTODIMS --  CONVERT BETWEEN A 1-D INDEX AND AN N-DIMENSIONAL INDEX OR VICE-VERSA
">[Previous Routine]</A>
<A HREF="#MAKEARR -- GENERATE AN N-EL ARRAY RUNNING FROM VALUES MIN TO MAX
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>

 LOOP_BAR
 A program to create a progress bar within a loop.

 Call sequence:
   BAR, I, IMAX [, IMIN=integer]

 Inputs:
   I - The index being advanced in the loop.
   IMAX - The value at the loop's finish.

 Outputs:
   Prints out a simple empty bar that fills up with 10 dashes as the
   loop completes.  Also prints percent complete and estimates time
   remaining.

 Keyword:
   IMIN - Include if IMIN is nonzero.  Default IMIN = 0.

 Calls:
   DELVARX (Goddard Routine)

 Katie Peek / August 2004
  Updated to include remaining time estimate - August 2005

</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/idlutils_carl/loop_bar.pro)</STRONG><P>
<HR>
 
<A NAME="MAKEARR -- GENERATE AN N-EL ARRAY RUNNING FROM VALUES MIN TO MAX">
<H2>MAKEARR -- GENERATE AN N-EL ARRAY RUNNING FROM VALUES MIN TO MAX</H2></A>
<A HREF="#LOOP_BAR">[Previous Routine]</A>
<A HREF="#
RDPLOT (TR_RDPLOT) -- LIKE CURSOR BUT WITH FULL-SCREEN CURSOR AND CONTINUOUS READOUT.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
MAKEARR -- generate an N-el array running from values MIN to MAX


 PURPOSE:
       This procedure will generate an array of lenght N which
       runs from values MIN to MAX

 CATEGORY:



 CALLING SEQUENCE:
       f = makearr(n, min, max [,fan=, transfan=, /double])


 INPUTS:

       N:    The number of desired array elements in F
       MIN:  The value of the first array element in F
       MAX:  The value of the last array element in F

 OPTIONAL INPUTS:

 KEYWORD PARAMETERS:

       FAN:        Number of times the array is to be repeated.
                   The final dimensions of F  will be N columns 
                   by FAN rows.
       /TRANSPOSE  Final dimensions of F wil be FAN columns by N 
                   rows if FAN is specified. 

 OUTPUTS:

       F:    Final array

 OPTIONAL OUTPUTS:



 COMMON BLOCKS:



 SIDE EFFECTS:



 RESTRICTIONS:



 PROCEDURE:



 EXAMPLE:

      If you want a 5 element array which runs from 2 to 4:

         IDL> f = makearr(5,2,4)
         IDL> print, f
             2.00000      2.50000      3.00000      3.50000      4.00000
         
 MODIFICATION HISTORY:
 Written by John "JohnJohn" Johnson somewhere around Oct-2001
 20 Feb 2002 JohnJohn- Added /FAN and /TRANSPOSE keywords.
 23 Feb 2002 JohnJohn- Calculations performed in double precision. 
                       Output in double precision if input is 
                       double.
 01 Mar 2002 Tim Robishaw- Spiffed up with a little Tim. 
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/idlutils_carl/makearr.pro)</STRONG><P>
<HR>
 
<A NAME="
RDPLOT (TR_RDPLOT) -- LIKE CURSOR BUT WITH FULL-SCREEN CURSOR AND CONTINUOUS READOUT.
">
<H2>
RDPLOT (TR_RDPLOT) -- LIKE CURSOR BUT WITH FULL-SCREEN CURSOR AND CONTINUOUS READOUT.
</H2></A>
<A HREF="#MAKEARR -- GENERATE AN N-EL ARRAY RUNNING FROM VALUES MIN TO MAX
">[Previous Routine]</A>
<A HREF="#SHOWFONT -- DISPLAY VECTOR-DRAWN FONTS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
RDPLOT (tr_rdplot) -- like CURSOR but with full-screen cursor and continuous readout.

 PURPOSE:
   Like CURSOR but with a full-screen cursor and continuous readout option
 EXPLANATION:
   This program is designed to essentially mimic the IDL CURSOR command,
   but with the additional options of continuously printing out the data
   values of the cursor's position, and using a full-screen cursor rather 
   than a small cross cursor.  The Full screen cursor uses OPLOT and 
   X-windows graphics masking to emulate the cursor.
      One difference is that IF the PRINT keyword is set but the DOWN, WAIT,
   or CHANGE keywords are not set, then the leftmost mouse button will 
   print a "newline" line-feed, but not exit.

 CALLING SEQUENCE:
   RDPLOT, [X, Y, WaitFlag], [/DATA, /DEVICE, /NORMAL,
      /NOWAIT, /WAIT, /DOWN, /CHANGE, ERR=,
      PRINT=, XTITLE=, YTITLE=, XVALUES=, YVALUES=,
      /FULLCURSOR, /NOCLIP, LINESTYLE=, THICK=, COLOR=, BACKGROUND=, /CROSS]

 REQUIRED INPUTS:
   None.

 OPTIONAL INPUTS: 
   WAITFLAG = Uses the same table as the intrinsic CURSOR command, But note
	that unlike the CURSOR command, there is no UP keyword.
		WaitFlag=0 sets the NOWAIT keyword
		WaitFlag=1 sets the WAIT keyword {default}
		WaitFlag=2 sets the CHANGE keyword
		WaitFlag=3 sets the DOWN keyword

 OPTIONAL OUTPUTS:
    X - a named variable to receive the final cursor X position, scalar
    Y - a named variable to receive the final cursor Y position, scalar
 OPTIONAL KEYWORD INPUT PARAMETERS:
   /DATA = Data coordinates are displayed and returned.
   /DEVICE = device coordinates are displayed and returned.
   /NORMAL = normal coordinates are displayed and returned.
          Default is to use DATA coordinates if available (see notes).
   /NOWAIT = if non-zero the routine will immediately return the cursor's
      present position.
   WAIT = if non-zero will wait for a mouse key click before returning.  If
      cursor key is already down, then procedure immediately exits.
   DOWN = equivalent to WAIT *except* that if the mouse key is already down
      when the procedure is called, the procedure will wait until the mouse
      key is clicked down again.
   CHANGE = returns when the mouse is moved OR a key is clicked up or down.
   PRINT = if non-zero will continuously print out (at the terminal) the data 
      values of the cursor's position.  If PRINT>1, program will printout a 
      brief header describing the mouse button functions.  However, note that 
      the button functions are overridden if any of the DOWN, WAIT, mouse
      or CHANGE values are non-zero.
   XTITLE = label used to describe the values of the abscissa if PRINT>0.
   YTITLE = label used to describe the values of the ordinate if PRINT>0.
   XVALUES = a vector corresponding to the values to be printed when the
	PRINT keyword is set.  This allows the user the option of printing
	out other values rather than the default X coordinate position of
	the cursor.  E.g., if XVALUES is a string vector of dates such as
	['May 1', 'May 2', ...], then those dates will be printed rather than
	the X value of the cursor's position: if X=1 then 'May 2' would be
	printed, etc.  This requires that the values of the X coordinate read
	by the cursor must be positive (can't access negative elements).
       If XVALUES=-1, then NO values for X will be printed.
   YVALUES = analagous to the XVALUES keyword.
   FULLCURSOR = if non-zero default cursor is blanked out and full-screen 
      (or full plot window, depending on the value of NOCLIP) lines are
      drawn; their intersecton is centered on the cursor position.
   NOCLIP = if non-zero will make a full-screen cursor, otherwise it will
      default to the value in !P.NOCLIP.
   LINESTYLE = style of line that makes the full-screen cursor.
   THICK = thickness of the line that makes the full-screen cursor.
   COLOR = color of the full-screen cursor.
   BACKGROUND = color of the background of the plot device.  If this has
      been set to !P.BackGround, then this keyword is unnecessary.
   CROSS = if non-zero will show the regular cross AND full screen cursors.

 OPTIONAL KEYWORD OUTPUT PARAMETER:
   ERR = returns the most recent value of the !mouse.button value.

 NOTES:
   Note that this procedure does not allow the "UP" keyword/flag...which 
   doesn't seem to work too well in the origianl CURSOR version anyway.

   If a data coordinate system has not been established, then RDPLOT will
   create one identical to the device coordinate system.   Note that this
   kluge is required even if the user specified /NORMAL coordinates, since
   RDPLOT makes use of the OPLOT procedure.  This new data coordinate system
   is effectively "erased" (!X.CRange and !Y.CRange are both set to zero)
   upon exit of the routine so as to not change the plot status from the
   user's point of view.

   Only tested on X-windows systems.  If this program is interrupted, the
   graphics function might be left in a non-standard state; in that case,
   run the program RESET_RDPLOT to return the standard graphics functions,
   or type the command:   DEVICE, /CURSOR_CROSS, SET_GRAPHICS=3, BYPASS=0

 BUGS:
   NOTE: (1/27/05) These bugs have been fixed by Robishaw and tested
   on Solaris, Linux and OS-X.

   It is assumed that the current background of the plot is correctly
   defined by the value in !P.Background.  Otherwise, the color of the
   long cursor probably will not be correct.  Sometimes the color doesn't
   work anyway, and I'm not sure why.
   NOTE: Robishaw fixed this 1/27/05.

   There may be some cases (e.g., when THICK>1 and NOCLIP=0) when the
   full-screen cursor is not correctly erased, leaving "ghost images" on the
   plot.  It just seems that the screen updates get slow or the positions
   ambiguous with a thick line and the cursor off the plot.
   NOTE: Robishaw fixed this 1/27/05.

 PROCEDURE:
   Basically is a bells-n-whistles version of the CURSOR procedure.  All
   the details are covered in the above discussion of the keywords.

 EXAMPLE (a silly, but informative one):
   Months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', $
             'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
   plot, indgen(12), xrange=[-5, 15]
   rdplot, /FULL, /PRINT, XTITLE='Month: ', YTITLE='Y-value per month = ', $
      xvalues=Months

 MODIFICATION HISTORY:
   Written (originally named CURFULL) by J.Wm.Parker  1993 Nov 22 
   Created data coordinates if not already present, W. Landsman Nov. 93
   Added continuous printout of data values, COLOR and FULLCURSOR keywords
      (so that default is that it acts just like the cursor command).
      Changed name from CURFULL to RDPLOT.   J.Wm.Parker  1994 Apr 20
   Modified (with some translation table assistance from the IDL support 
      group) to correctly plot the crosshair with the desired IDL 
      color using the device's translation table to determine the XOR 
      function and using the BYPASS function.  Added the RESET_RDPLOT
      procedure to cleanup crashes that might occur while running
      RDPLOT.  Other minor changes/bug fixes.  J.Wm.Parker  1994 May 21
   Modified DOWN, WAIT, CHANGE functions to behave more similar to the
      generic CURSOR procedure.   J.Wm.Parker  1995 April 24
   Added XVALUES, YVALUES keywords and cleanup.   J.Wm.Parker  1995 April 24
   Convert to IDL V5.0,  W. Landsman    July 1998
   Change !D.NCOLORS to !D.TABLE_SIZE for 24 bit displays W. Landsman May 2000
   Skip translation table for TrueColor visuals   W. Landsman  March 2001
   Fixed /FULLCURSOR ghosts. Fixed to properly deal with background colors
      in 24-bit visual classes (TrueColor and DirectColor).
      Tim Robishaw 2005 Jan 27       
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/idlutils_carl/tr_rdplot.pro)</STRONG><P>
<HR>
 
<A NAME="SHOWFONT -- DISPLAY VECTOR-DRAWN FONTS">
<H2>SHOWFONT -- DISPLAY VECTOR-DRAWN FONTS</H2></A>
<A HREF="#
RDPLOT (TR_RDPLOT) -- LIKE CURSOR BUT WITH FULL-SCREEN CURSOR AND CONTINUOUS READOUT.
">[Previous Routine]</A>
<A HREF="#TRC">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
SHOWFONT -- display vector-drawn fonts

 PURPOSE:
	This procedure displays a vector-drawn font on the current
	graphics device.

 CATEGORY:
	Fonts.

 CALLING SEQUENCE:
	SHOWFONT, Font [, Name]

 INPUTS:
	Font:	 The index number of the font (may range from 3 to 29)
		 or, if the TT_FONT keyword is set, a string representing
                the name of the TrueType font to display.
	Name:	 Title text to appear at top of display.

 KEYWORD PARAMETERS:
	ENCAPSULATED:	If this keyword is set, and if the current graphics
			device is "PS", makes encapsulated PostScript output.
	TT_FONT:	If this keyword is set, the Font argument is 
			interpreted as the name of a TrueType font.

 OUTPUTS:
	No explicit outputs.

 SIDE EFFECTS:
	A display is made.

 RESTRICTIONS:
	Not very flexible.

 PROCEDURE:
	Straightforward.

 EXAMPLE:
	To create a display of Font 3 for PostScript:
		SET_PLOT, 'PS'
		SHOWFONT, 3, "Simplex Roman"

	To create a display of the Times Roman TrueType font:
		SHOWFONT, 'Times', 'Times Roman', /TT_FONT

 MODIFICATION HISTORY:
 	Written by:
	DMS, Nov, 1992
	WSO, 1/95, Updated for new directory structure
	DD, 12/97, Updated to handle TrueType fonts
       Erik Rosolowsky, added forward subscripts in roman and trapped
       the passage of an empty name string. (1/26/05)
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/idlutils_carl/showfont.pro)</STRONG><P>
<HR>
 
<A NAME="TRC">
<H2>TRC</H2></A>
<A HREF="#SHOWFONT -- DISPLAY VECTOR-DRAWN FONTS">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
name:
TRC -- tim's full-screen cursos with carl's preferred features.
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/idlutils_carl/trc.pro)</STRONG><P>
<HR>
 
</body>
</html>
