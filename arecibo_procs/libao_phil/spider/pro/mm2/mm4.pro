;<04aug07> added nominal_linear keyword passed to mmlsfit
function  mm4, path, muellerparams_init, $
	indx, hb_arr, mInfo_arr, beamin_arr, beamout_arr,stkOffsets_chnl_arr, $
	muellerparams1, muellerparams_chnls, $
	plt0yes=plt0yes, plt1yes=plt1yes, ps1yes=ps1yes, $
	check=check, negate_q=negate_q, byChnl=byChnl, m7=m7,$
	nominal_linear=nominal_linear

;+
; PURPOSE: Generate mueller matrix elements; plot intermediate results
;if desirec. print and plot and make ps files of final results if
;desired. Replaces the old mueller4.idlprc.pro
;
;INPUTS:
;	INDX, the array of indices to process
;	A, BEAMOUT_ARR, the structures generated by mm0.
;
;KEYWORDS:
;
;	PLT0YES: plots intermediate results (PA dependencies on the
;screen); usually not set unless there are problems with the fit.
;
;       PLT1YES: plots final results on the screen--the PA dependencies
;plus the Mueller paramters and matrix elements.
;
;	PLT1YES: plots final results on the screen. 
;
;	PS1YES: generates ps file with final results.
;
;       CHECK: checks the calc by plotting on the screen the
;mm-corrected input data; derived MM elements should be zero. Normally
;don't bother with this; useful for pgrm development and looking into  
;problems wiht fits.
;       
;	NEGATE_Q=NEGATE_Q: multiplies uncorrected xmy by -1. always use 0.
;
;	CHNL: if set, it does all the channels as well as the 
;continuum. this is done at the end. channels come 
;from stkoffsets_chnl_arr
;
;	M7: if set, it gets the continuum using the 'M7' method. This
;means that it tries to excise interference from each spectrum. I'M NOT
;SURE THAT THE M7 OPTION WORKS VERY WELL...IT MAY NEED WORK...
;
;	BEAMIN_ARR contains all the spectral data and must be included
;if M7 is set.
;       NOMINAL_LINEAR: if set, forces abs(alpha) lt 45deg and adjusts psi.
;
;OUTPUTS:
;	stat: 0 not fit, 1 fit completed
;	plotfiles, plots pa output files if desired.
;
;	output file with the derived results	
;
;	MUELLERPARAMS1, the output muellerparams structure.
;
;-

forward_function muellerparams_init
	returnstat=0

	numIndx=n_elements(indx)
	IF ( numIndx LT 4) THEN BEGIN
		print, 'SKIP MUELLER4 FOR THIS SOURCE--FEWER THAN FOUR PATTERNS'
		return,returnstat
	ENDIF

;	GET THE NORMALIZED DATA...

	if ( n_elements( negate_q) eq 0) then negate_q= 0

;STOP

	print,'Enter mm4'
	IF ( KEYWORD_SET( M7)) THEN BEGIN
		make_mmlsfit_inputs_m7, indx, mInfo_arr, beamin_arr, beamout_arr, $
   	     stkOffsets_chnl_arr,qpa, xpy, xmy, xy, yx, $
   	     muellerparams_init, muellerparams0, pacoeffs, ngoodpoints, $
   	     mueller_az=mueller_az, negate_q=negate_q
	ENDIF ELSE begin
		make_mmlsfit_inputs, indx,mInfo_arr, beamout_arr, $
        qpa, xpy, xmy, xy, yx, $
        muellerparams_init, muellerparams0, pacoeffs, ngoodpoints, $
        mueller_az=mueller_az, negate_q=negate_q
	endelse
	 
;PLOT THE PA DEP OF THE UNCORRECTED DATA...
;	DO IT HERE IN CASE THE MMLSFIT FAILS SO YOU CAN SEE WHAT THE
;	PROBLEM IS...
	if ( keyword_set(plt0yes)) then plot_stokespa, 0, indx,mInfo_arr, $
        qpa, xpy, xmy, xy, yx, $
        pacoeffs, ps=ps1yes, title=title

;DO THE LS FIT...
;stop
	mmlsfit, pacoeffs, muellerparams0, muellerparams1, $
		nloop, cov, fixpsi=muellerparams0.fixpsi, $
		/fixchi, nominal_linear=nominal_linear
;stop

;
;	fill in the reference info for this fit
;
	returnstat=1
	muellerparams1.scan1  =mInfo_arr[indx[0]].scan
	muellerparams1.scan2  =mInfo_arr[indx[numIndx-1]].scan
	muellerparams1.npat   =numIndx
	muellerparams1.srcname=mInfo_arr[indx[0]].srcname
	muellerparams1.cfr    =mInfo_arr[indx[0]].cfr
	muellerparams1.brd    =mInfo_arr[indx[0]].brd
	muellerparams1.rcvnum =mInfo_arr[indx[0]].rcvnum
	muellerparams1.julday =mInfo_arr[indx[0]].julday
;STOP

;------------ PLOT, PRINT THE RESULTS IF DESIRED--------------------

;PRINT THE RESULTS ON THE TERMINAL WINDOW...
IF ( keyword_set(PLT1YES)) THEN BEGIN
print_stokespa, indx, mInfo_arr, muellerparams1, ngoodpoints, nloop
;PLOT AND PRINT THE RESULTS ON WINDOW 9
windownr=9
nrps=0
prtplot, nrps, windownr, indx, mInfo_arr, muellerparams1, $
        qpa, xpy, xmy, xy, yx, pacoeffs, ngoodpoints, $
        title=title
ENDIF

;MAKE THE PS PLOTFILE...
IF ( keyword_set(PS1YES)) THEN BEGIN
pltfilename, indx, mInfo_arr, 'm4', '.ps', title, plotfilename
nrps=1
;
plotcolors,/ps
prtplot, nrps, windownr, indx, mInfo_arr, muellerparams1, $
        qpa, xpy, xmy, xy, yx, pacoeffs, ngoodpoints, $
        title=title, path=path, plotfilename=plotfilename
plotcolors

ENDIF

;--------------- FINISHED PLOTTING THE RESULTS ---------------


;---------------- CHECK IF DESIRED -------------------------------
;CORRECT THE INPUT DATA AND DO THE PA FIT AGAIN...
IF (not keyword_set(CHECK)) THEN GOTO, FINISHED

mm_corr_strpfit, indx, ( muellerparams1.m_tot), beamout_arr, $
	beamcorrected_arr

;NOTE THAT THE M_TOT INVERSION IS NOW DONE IN THE CORRECTION PGM, SO WE
;USE THE ABOVE STATEMENT INSTEAD OF THE ONE BELOW...
;mm_corr_strpfit, indx, invert( muellerparams1.m_tot), beamout_arr, $
;	beamcorrected_arr

;DO THE LS FIT...
make_mmlsfit_inputs, indx, mInfo_arr, beamcorrected_arr, $
        qpa, xpy, xmy, xy, yx, $
        muellerparams1, muellerparams1, pacoeffs, ngoodpoints, $
        mueller_az=mueller_az, negate_q=negate_q

;------------ BEGIN PLOTTING THE RESULTS FOR CHECKED DATA-------------
;--------------THIS IS ALWAYS DONE IF CHECK IS SET--------------------
;PLOT THE PA DEP OF THE UNCORRECTED DATA...
plot_stokespa, 1, indx, mInfo_arr, $
        qpa, xpy, xmy, xy, yx, $
        pacoeffs, ps=ps, title=title
mmlsfit, pacoeffs, $
	muellerparams0, muellerparams2, $
	nloop, cov, $
	fixpsi=muellerparams0.fixpsi, $
	/fixchi, nominal_linear=nominal_linear

;PLOT AND PRINT THE CHECK RESULTS ON WINDOW 10
windownr=10
nrps=0
prtplot, nrps, windownr, indx, mInfo_arr, muellerparams2, $
        qpa, xpy, xmy, xy, yx, pacoeffs, ngoodpoints, $
        title=title


;----------- DO CHNL-BY-CHNL FITS IF DESIRED ---------------------------
FINISHED:

szzz= size( beamout_arr.stripfit_chnl)
nchnls= mInfo_arr[ indx[0]].nchnls
muellerparams_chnls= replicate( muellerparams_init(), nchnls)

IF (KEYWORD_SET( byChnl)) THEN BEGIN
	muellerparams_chnls.scan1=muellerparams1.scan1
    muellerparams_chnls.scan2=muellerparams1.scan2
    muellerparams_chnls.npat=muellerparams1.npat
    muellerparams_chnls.srcname=muellerparams1.srcname
    muellerparams_chnls.cfr=muellerparams1.cfr
    muellerparams_chnls.brd=muellerparams1.brd
    muellerparams_chnls.rcvnum=muellerparams1.rcvnum
    muellerparams_chnls.julday=muellerparams1.julday

	npat=n_elements(indx)
	print,'Fitting ',npat,' patterns by freq channel'
	for nrc=0, npat-1  do begin
		if (nrc mod 5) eq 0 then print,'Starting pattern:',nrc
		print,'nrc:',nrc
 		beam1dfit, indx[ nrc], beamin_arr, beamout_arr,  stkOffsets_chnl_arr,$
 					byChnl=byChnl
	endfor

	FOR NCH= 0, NCHNLS-1 DO BEGIN

;		GET THE NORMALIZED DATA...
			make_mmlsfit_inputs, indx, mInfo_arr, beamout_arr, $
        		qpa, xpy, xmy, xy, yx, $
        		muellerparams_init, muellerparams0, pacoeffs, ngoodpoints, $
        		mueller_az=mueller_az, negate_q=negate_q, chnl=nch

;	PLOT THE PA DEP OF THE UNCORRECTED DATA...
;	DO IT HERE IN CASE THE MMLSFIT FAILS SO YOU CAN SEE WHAT THE
;	PROBLEM IS...
		if ( keyword_set(plt0yes) ) then plot_stokespa, 0, indx,mInfo_arr,$
        		qpa, xpy, xmy, xy, yx, pacoeffs, ps=ps, title=title

;	DO THE LS FIT...
			mmlsfit, pacoeffs, muellerparams0, muellerparamschnl, $
				nloop, cov, fixpsi=muellerparams0.fixpsi, $
				/fixchi, nominal_linear=nominal_linear

			muellerparams_chnls[ nch]= muellerparamschnl

	endfor

;	ALWAYS PRODUCE PS PLOTS BECAUSE THIS CALCULATION IS SO EXPENSIVE...

	m5plot, path, indx, mInfo_arr, muellerparams_chnls, /ps

ENDIF

return,returnstat

end
