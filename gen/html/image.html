<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>image procs</TITLE>
</head>
 
<body>
<H1>image procs</H1>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help</CODE>.  For more information on 
this routine, refer to the IDL Online Help Navigator 
or type: <P>
<PRE>     ? mk_html_help</PRE><P>
at the IDL command line prompt.<P>
<STRONG>Last modified: </STRONG>Tue Dec 20 11:48:26 2005.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#
DISPLAY2PAR -- DISPLAY INTENSITY/COLOR (2D COLOR IMAGE) USING PSEUDOCOLOR TABLE
">
DISPLAY2PAR -- DISPLAY INTENSITY/COLOR (2D COLOR IMAGE) USING PSEUDOCOLOR TABLE
</A>
<LI><A HREF="#
DSPLY2D -- DISPLAY INTENSITY/COLOR (2D COLOR IMAGE) USING PSEUDOCOLOR TABLE">
DSPLY2D -- DISPLAY INTENSITY/COLOR (2D COLOR IMAGE) USING PSEUDOCOLOR TABLE</A>
<LI><A HREF="#IMAGEALIGN -- ALIGN TWO IMAGES OF THE SAME FIELD">
IMAGEALIGN -- ALIGN TWO IMAGES OF THE SAME FIELD</A>
<LI><A HREF="#OPLOTBEAM">OPLOTBEAM</A>
<LI><A HREF="#OPLOTSCALE">OPLOTSCALE</A>
<LI><A HREF="#PROFILES">PROFILES</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="
DISPLAY2PAR -- DISPLAY INTENSITY/COLOR (2D COLOR IMAGE) USING PSEUDOCOLOR TABLE
">
<H2>
DISPLAY2PAR -- DISPLAY INTENSITY/COLOR (2D COLOR IMAGE) USING PSEUDOCOLOR TABLE
</H2></A>
<A HREF="#
DSPLY2D -- DISPLAY INTENSITY/COLOR (2D COLOR IMAGE) USING PSEUDOCOLOR TABLE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
display2par -- display intensity/color (2d color image) using pseudocolor table
 KEYWORDS: ENCAPSULATED

style =1 means put axes on the image; 5 means not.
xaxlbl and yaxlbl are the x and y axis labels.

 !!!!!!
 leave the ps device open!

 !!!!! PROBABLY SMARTER WAY TO DO CONGRID THAN JUST TAKING 541 PIXELS???
 !!!!! WHAT DO WE DO ABOUT VALUES WE REALLY WANT TO IGNORE?
 A COLOR FIELD WITH VALUES FROM -320 TO -200 WILL HAVE A BUNCH
 OF ZEROS WHERE THERE'S NO DATA.  WHAT IF COLOR STRETCHED FROM -10 TO
 +10, THEN TROUBLE CITY.  --> NAN!!!!

 MAKE A COLORBAR AND IMAGE WITH COLOR/INTENSITY
 USE 24 BIT COLOR

 how would figure out what xsize/ysize (before you get here) to feed
 psopen in order to make correct aspect ratio???

 EXAMPLES:
 IDL> psopen, 'color_inensity.ps', /COLOR
 IDL> display2par, vimage, timage, ra, dec, epoch=2002
 IDL> psclose

 assumes rectangular region of sky.  if curvature is important (high
 latitude) then you have to modify this routine.

 CHECK TO MAKE SURE BOTH PARAMETER MAPS HAVE THE SAME SIZE...
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/image/display2par.pro)</STRONG><P>
<HR>
 
<A NAME="
DSPLY2D -- DISPLAY INTENSITY/COLOR (2D COLOR IMAGE) USING PSEUDOCOLOR TABLE">
<H2>DSPLY2D -- DISPLAY INTENSITY/COLOR (2D COLOR IMAGE) USING PSEUDOCOLOR TABLE
</H2></A>
<A HREF="#
DISPLAY2PAR -- DISPLAY INTENSITY/COLOR (2D COLOR IMAGE) USING PSEUDOCOLOR TABLE
">[Previous Routine]</A>
<A HREF="#IMAGEALIGN -- ALIGN TWO IMAGES OF THE SAME FIELD">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
dsply2d -- display intensity/color (2d color image) using pseudocolor table
 KEYWORDS: ENCAPSULATED

style =1 means put axes on the image; 5 means not.
xaxlbl and yaxlbl are the x and y axis labels.

 !!!!!!
 leave the ps device open!

 !!!!! PROBABLY SMARTER WAY TO DO CONGRID THAN JUST TAKING 541 PIXELS???
 !!!!! WHAT DO WE DO ABOUT VALUES WE REALLY WANT TO IGNORE?
 A COLOR FIELD WITH VALUES FROM -320 TO -200 WILL HAVE A BUNCH
 OF ZEROS WHERE THERE'S NO DATA.  WHAT IF COLOR STRETCHED FROM -10 TO
 +10, THEN TROUBLE CITY.  --> NAN!!!!

gryrev: set if this is a negative (bright means small) instead of pos (bright means large)

 MAKE A COLORBAR AND IMAGE WITH COLOR/INTENSITY
 USE 24 BIT COLOR

 how would figure out what xsize/ysize (before you get here) to feed
 psopen in order to make correct aspect ratio???

 EXAMPLES:
 IDL> psopen, 'color_inensity.ps', /COLOR
 IDL> dsply2dcbl, vimage, timage, ra, dec, epoch=2002
 IDL> psclose

 assumes rectangular region of sky.  if curvature is important (high
 latitude) then you have to modify this routine.

 CHECK TO MAKE SURE BOTH PARAMETER MAPS HAVE THE SAME SIZE...
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/image/dsply2d.pro)</STRONG><P>
<HR>
 
<A NAME="IMAGEALIGN -- ALIGN TWO IMAGES OF THE SAME FIELD">
<H2>IMAGEALIGN -- ALIGN TWO IMAGES OF THE SAME FIELD</H2></A>
<A HREF="#
DSPLY2D -- DISPLAY INTENSITY/COLOR (2D COLOR IMAGE) USING PSEUDOCOLOR TABLE
">[Previous Routine]</A>
<A HREF="#OPLOTBEAM">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
IMAGEALIGN -- align two images of the same field

PURPOSE:
	This procedure take two images of the same field and aligns them
exactly. 

CALLING SEQUENCE:
	IMAGEALIGN, Im1, Im2, Boxsize

INPUTS:
	Im1: The image used as the 'standard' to which Im2 will be
aligned. 

	Im2: The image that should be moved to be aligned with Im1. 

OPTIONAL INPUTS:

	Boxsize: This is the size of the area used in the cross
correlation calculation.  A larger Boxsize means a larger area is
included in the calculation, which includes more stars in the cross
correlation, which usually leads to more accurate alignment. 

	However, the computation time goes as Boxsize SQUARED.  The
default boxsize is 128. 

OUTPUTS:
	There are no outputs.  The amount by which Im2 needs to be moved
is printed on the screen and you are given the choice as to whether to
move Im2 by this amount or not. 

RESTRICTIONS:
	The input images must be FLOATING POINT (i.e., REAL) numbers. 

	You are asked to move the cursor onto a star and click; this
defines the center of the box used in the cross correlation.  This
center doesn't HAVE to be a star; it can be any point.  But this point
must be at least as far from the edge of the image as Boxsize. 

PROCEDURE:
	This routine first removes the sky background by convolving each
image with a small second-derivative type of kernal (6 X 6 pixels). 
Then it cross-correlates the two images and finds the position where the
cross-correlation is maximum.  Then it prints out the amount by which
the Im2 needs to be shifted and asks you if you want to actually move
Im2 by this amount.  When doing the moving, we use the IDL SHIFT
procedure, in which the edges of Im2 are 'wrapped around' so that no
information is lost; you can move it back to the original position with
SHIFT and no information is lost. 

EXAMPLE:
	Get Im1 into a window.  Then type IMAGEALIGN, Im1, Im2, Boxsize. 

HISTORY:
	Written by Carl Heiles.  Documented 13 Dec 1997.  Modified 13
Dec 1997 to check if images are real numbers. 
Modified 9 Nov 1998 to do images of arbitrary size (it was 512)
Updated documentation 19 Oct 99.
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/image/imagealign.pro)</STRONG><P>
<HR>
 
<A NAME="OPLOTBEAM">
<H2>OPLOTBEAM</H2></A>
<A HREF="#IMAGEALIGN -- ALIGN TWO IMAGES OF THE SAME FIELD
">[Previous Routine]</A>
<A HREF="#OPLOTSCALE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       OPLOTBEAM

 PURPOSE:
       Draw a half-power beam ellipse on an already-existing plot.

 CALLING SEQUENCE:
       OPLOTBEAM, xcenter, ycenter, hpbw_major [, hpbw_minor] [,
       /NOFILL] [, ANGLE=ccw_degrees_from_horiz]

 Other keywords accepted by both PLOTS and POLYFILL:
       [, CLIP=[X0, Y0, X1, Y1]] [, COLOR=value] 
       [, /DATA | , /DEVICE | , /NORMAL] 
       [, LINESTYLE={0 | 1 | 2 | 3 | 4 | 5}] [, /NOCLIP] [, THICK=value]

 Other POLYFILL keywords accepted:
       [, /LINE_FILL] [, ORIENTATION=ccw_degrees_from_horiz]  
       [, PATTERN=array] [, SPACING=centimeters] 

 INPUTS:
       XCENTER - Horizontal coordinate used to position the center of
                 the beam area.  Assumed to be in DATA coordinates;
                 override this with /NORMAL or /DEVICE keywords.

       YCENTER - Vetical coordinate used to position the center of
                 the beam area. Assumed to be in DATA coordinates;
                 override this with /NORMAL or /DEVICE keywords.

       HPBW_MAJOR - The half-power beamwidth of the major axis of the 
                    telescope beam.  If the beam is circular, then this
                    parameter is all that is necessary to define the beam.
                    Must be given in the same coordinate system (DATA,
                    DEVICE, NORMAL) as the XCENTER and YCENTER
                    parameters.  Assumed to be in DATA coordinates;
                    override this with /NORMAL or /DEVICE keywords.

 OPTIONAL INPUTS:
       HPBW_MINOR - If the beam is elliptical, then this is the half-power 
                    beamwidth of the minor axis of the telescope beam.

 KEYWORD PARAMETERS:
       /NOFILL: Set this keyword if you want only the boundary of the beam
                area to be drawn.

       ANGLE = Specifies the counterclockwise angle in degrees from 
               horizontal of the major axis of the beam ellipse.
               Remember that astronomical position angles are
               measured from the North towards the East.  If you've
               displayed your map correctly, and you know the PA of
               your beam, set ANGLE to 90+PA.

 OUTPUTS:
       None.

 COMMON BLOCKS:
       None.

 SIDE EFFECTS:
       A beam ellipse is drawn on the current display device.

 EXAMPLE:
       A map has been established on the display device.  Choose a
       nice uncluttered place to draw the beam ellipse using the
       cursor:

       IDL> cursor, x, y

       Try the default, a filled ellipse with the major axis along
       the horizontal (the values of hpbw_maj and hpbw_min must be in
       the same coordinates as x and y, in this case DATA coordinates):

       IDL> oplotbeam, x, y, hpbw_maj, hpbw_min

       Get fancy by adding a line fill at an orientation of 30
       degrees ccw from the horizontal, increasing the line
       thickness, and drawing the beam in color:

       IDL> oplotbeam, x, y, hpbw_maj, hpbw_min, THICK=3, $
       IDL> COLOR=green, ORIENTATION=-30

       Now, also tilt the major axis of the beam at an angle
       of 30 degrees ccw from horizontal:

       IDL> oplotbeam, x, y, hpbw_maj, hpbw_min, THICK=3, $
       IDL> COLOR=green, ORIENTATION=-30, ANGLE=-30

 NOTES:
       Defaults:
       (1) Plots major axis of the beam ellipse parallel to the
           horizontal.  Use ANGLE keyword to change this orientation
           of the ellipse.
       (2) Fills the ellipse with a solid pattern.  To prevent the
           ellipse from being filled, set the /NOFILL keyword.  To
           fill the ellipse with lines, set the /LINE_FILL keyword
           and/or the ORIENTATION keyword.

 RELATED PROCEDURES:
       OPLOTSCALE

 MODIFICATION HISTORY:
   26 Mar 2004  Written by Tim Robishaw, Berkeley
   31 Mar 2004  Fixed angle so that CCW is always CCW, even if X axis
                or Y axis is running backwards. TR
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/image/oplotbeam.pro)</STRONG><P>
<HR>
 
<A NAME="OPLOTSCALE">
<H2>OPLOTSCALE</H2></A>
<A HREF="#OPLOTBEAM">[Previous Routine]</A>
<A HREF="#PROFILES">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       OPLOTSCALE

 PURPOSE:
       Draw a scale bar on an already-existing plot.

 CALLING SEQUENCE:
       OPLOTSCALE, xcenter, ycenter, scale, scale_string [,
       /ABOVE | /BELOW | /LEFT | /RIGHT] [, /NOHAT] [, THICK=value] [, 
       COLOR=value] [, CHARSIZE=value] [, CHARTHICK=value] [, 
       FONT=integer]

 INPUTS:
       XCENTER - Horizontal coordinate used to position the center
                 of the scale bar.  Must be given in DATA coordinates.

       YCENTER - Vertical coordinate used to position the center
                 of the scale bar.  Must be given in DATA coordinates.

       SCALE - The length of the scale bar in DATA coordinates.

       SCALE_STRING - String containing the scale size and units of
                      the scale bar.

 OUTPUTS:
       None.

 KEYWORD PARAMETERS:
       /ABOVE - Places the scale bar annotation ABOVE the scale bar;
                this is the default.

       /BELOW - Places the scale bar annotation BELOW the scale bar.

       /LEFT - Places the scale bar annotation to the left of the
               scale bar.

       /RIGHT - Places the scale bar annotation to the right of the
                scale bar.

       /NOHAT - If this keyword is set, the scale bar is drawn without 
                hats at each end.  Default is to draw hats.

       THICK = The line thickness.

       COLOR = The color index of the scale bar and the scale text.

       CHARSIZE = The overall character size for the annotation of the 
                  scale.

       CHARTHICK = An integer value specifying the line thickness of 
                   characters.

       FONT = An integer that specifies the graphics text font system to 
              use. Set FONT equal to 0 (zero) to select the device font 
              (e.g., PostScript font).

 COMMON BLOCKS:
       None.

 SIDE EFFECTS:
       A scale bar is drawn on the current display device.

 RESTRICTIONS:
       A plot must already be established.  All inputs must be in
       DATA coordinates.

 EXAMPLE:
       A map has been established on the display device.  Choose a
       nice uncluttered place to draw the scale bar using the
       cursor:

       IDL> cursor, x, y

       Now display the scale bar and its annotation:

       IDL> oplotscale, x, y, scale, scale_string

       To place the annotation to the right of the scale bar, set the
       /RIGHT keyword:

       IDL> oplotscale, x, y, scale, scale_string, /RIGHT

       To place the annotation below the scale bar, set the /BELOW
       keyword; to remove the hats at each end of the scale bar, set
       the /NOHAT keyword:

       IDL> oplotscale, x, y, scale, scale_string, /BELOW, /NOHAT

 NOTES:
       Defaults:
       (1) Plots hats at the each end of scale bar.  The hats will
           have the height of one character.  Set the /NOHAT keyword
           to exclude the hats.

       (2) Places the scale annotation above the scale bar.  Set the
           /LEFT, /RIGHT, or /BELOW keywords to place the text to the
           right of, to the left of, or below the scale bar,
           respectively.

 RELATED PROCEDURES:
       OPLOTBEAM

 MODIFICATION HISTORY:
   26 Mar 2004  Written by Tim Robishaw, Berkeley
   31 Mar 2004  Added /LEFT, /RIGHT, /BELOW keywords. TR
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/image/oplotscale.pro)</STRONG><P>
<HR>
 
<A NAME="PROFILES">
<H2>PROFILES</H2></A>
<A HREF="#OPLOTSCALE">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	PROFILES

 PURPOSE:
	Interactively draw row or column profiles of an image in a separate
	window.

 CATEGORY:
	Image analysis.

 CALLING SEQUENCE:
	PROFILES, Image [, SX = sx, SY = sy] [, /AXIS] [, ORDER=order]
        [, WSIZE=wsize | , XSIZE=xsize, YSIZE=ysize]
        [, PSYM=psym] [, SSIZE=ssize] [, COLOR=color] 
        [, CCOLOR=ccolor] [, CLENGTH=clength] [, /CCLIP]

 INPUTS:
	Image:	The variable that represents the image displayed in current
		window.  This data need not be scaled into bytes.
		The profile graphs are made from this array.

 KEYWORD PARAMETERS:
       ORDER:	Set this keyword param to 1 for images written top down or
		0 for bottom up.  Default is the current value of !ORDER.

       /AXIS:  Set this keyword if the image intensities are to be plotted 
               against axis value rather the pixel number.  The image
               must be bordered by an axis for this to work properly.

	SX:	Starting X position (in device coordinates) of the
               image in the window.  The default value is 0.

	SY:	Starting Y position (in device coordinates) of the
               image in the window.  The default value is 0.

       WSIZE:	The size of the PROFILES window as a fraction or multiple
		of 640 by 512.

       XSIZE:  The width of the profiles window in pixels.

       YSIZE:  The height of the profiles window in pixels.

       PSYM:   The plotting symbol used to plot the profile.

       SSIZE:  The symbol size of the plot symbols.

       COLOR:  The color of the plot symbols.

       CCOLOR: The color of the cross marking the cursor position.

       CLENGTH: The length of the cross marking the cursor position,
                expressed as a fraction of the window size.  Default
                size is 0.1.  A value of >1.0 produces a cursor that
                extends to each axis.

       /CCLIP: Set this keyword to force cursor-position cross to be
               clipped at the axes.  Especially useful when setting
               CLENGTH to a value > 1.

 OUTPUTS:
	No explicit outputs.

 COMMON BLOCKS:
	None.

 SIDE EFFECTS:
	A new window and two new pixmap windows are created and used
	for the profiles.  When done, the new windows are deleted and
	the system variables !p, !x, and !y are restored for the image
	window.

 RESTRICTIONS:
	None.

 PROCEDURE:
	A new window is created and the mouse location in the original
	window is used to plot profiles in the new window.  Pressing the
	left mouse button toggles between row and column profiles.
	The right mouse button exits.

 EXAMPLE:
	Create and display an image and use the PROFILES routine on it.
	Create and display the image by entering:

		A = BYTSCL(DIST(256))
		TV, A

	Run the PROFILES routine by entering:

		PROFILES, A

	The PROFILES window should appear.  Move the cursor over the original
	image to see the profile at the cursor position.  Press the left mouse
	button to toggle between row and column profiles.  Press the right
	mouse button (with the cursor over the original image) to exit the
	routine.


       Take advantage of new bells and whistles.  Display an image
       and surround it with axes...
       IDL> loadct, 5
       IDL> image = findgen(250,250)
       IDL> tv, bytscl(image), 101, 101
       IDL> plot, [0], POSITION=[100,100,351,351], /DEVICE, /NOERASE

       Make sure it's backwards compatible! Does it work like it used to?
       IDL> profiles, image, sx=101, sy=101

       Now add some new keywords; make the data blue and the cross red: 
       IDL> device, DECOMPOSED=0
       IDL> profiles, image, sx=101, sy=101, COLOR=48, CCOLOR=110

       Now add the /AXIS keyword to plot the profiles against axis values 
       rather than pixel number, and make the PROFILES window larger:
       IDL> profiles, image, sx=101, sy=101, /AXIS, XSIZE=500, YSIZE=500

       Now plot the data as small diamonds; also, make the cross fill the 
       entire axis range and clip the cross at the axes:
       IDL> profiles, image, sx=101, sy=101, /AXIS, XSIZE=500, YSIZE=500, $
       IDL> COLOR=48, PSYM=4, SSIZE=0.1, CCOLOR=110, CLENGTH=1.5, /CCLIP

 NOTES:
       The IDL routine PROFILES has been rewritten to reflect 16 years of 
       IDL development, and a little cleverness.  

       Here is what has been changed:
       (1) Rather than redrawing the plot every time the cursor is moved,
       a pixmap is created to store a template of the axes, then the 
       template is dumped to another pixmap in which the plot data are 
       drawn; finally, this pixmap is dumped into the display window.
       This allows for a smooth animation of the profiles.
       This also prevents the gradual erasing of your axes and labels
       by the cursor-position cross that was a "feature" of the 
       previous PROFILES.
       (2) The axis styles are chosen more intelligently to not waste
       space and to leave a little buffer between the axes and data.
       (3) Unlike the previous version, does not turn the cursor off after 
       the profile window is closed.  I never understood this behavior!
       (4) Restores the !p, !x, and !y system variables for the image 
       window upon exiting; the previous version lost this information.

       Here is what has been added:
       (1) The axes are labelled to minimize the amount of user thought.
       (2) Added XSIZE and YSIZE keywords for manually setting the
       width and height (in pixels) of the PROFILES window.
       (2) Added the PSYM, SSIZE, and COLOR keywords to allow the profile 
       data to be plotted with the user's choice of symbol, size and 
       color, respectively.
       (3) Added the CCOLOR keyword to allow the cursor-position cross
       to have a different color than the data, making it easier to see.
       (4) Added the CLENGTH keyword to allow the user to change the
       size of the cursor-position cross.  A value > 1.0 will cause
       the cross to extend to each axis.
       (5) Added the /CCLIP keyword to prevent the cursor-position
       cross from extending beyond the axes; useful when CLENGTH>1.
       (6) Added the /AXIS keyword.  When set, rather than plotting
       the profile as a function of row number or column number, the
       profile is plotted as a function of the row or column values.
       The image must be bounded by axes for this option to produce
       meaningful results.

       All the changes and additions leave PROFILES backwards compatible
       such that any routines that called PROFILES will not need to be
       changed and the performance of the routine will not be changed!

 MODIFICATION HISTORY:
	DMS, Nov, 1988.
       16 Mar 2004  Complete overhaul. Tim Robishaw, Berkeley
       09 Jun 2004  If /AXIS is set, use the lower left corner of
                    the axes instead of setting SX and SY.
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/image/profiles.pro)</STRONG><P>
<HR>
 
</body>
</html>
