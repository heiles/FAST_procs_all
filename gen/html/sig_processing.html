<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>sig_processing procs</TITLE>
</head>
 
<body>
<H1>sig_processing procs</H1>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help</CODE>.  For more information on 
this routine, refer to the IDL Online Help Navigator 
or type: <P>
<PRE>     ? mk_html_help</PRE><P>
at the IDL command line prompt.<P>
<STRONG>Last modified: </STRONG>Tue Dec 20 11:48:26 2005.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#CLEAN_SP">CLEAN_SP</A>
<LI><A HREF="#
CUMFILTER -- FILTER BAD DATA USING CUMULATIVE DISTRIBUTION FUNCTION.">
CUMFILTER -- FILTER BAD DATA USING CUMULATIVE DISTRIBUTION FUNCTION.</A>
<LI><A HREF="#DFT -- DIRECT FT USING IDL CONVENTION FOR FORWARD/REVERSE">
DFT -- DIRECT FT USING IDL CONVENTION FOR FORWARD/REVERSE</A>
<LI><A HREF="#FSHIFT -- LIKE IDL'S SHIFT, BUT DOES FRACTIONAL SHIFTS">
FSHIFT -- LIKE IDL'S SHIFT, BUT DOES FRACTIONAL SHIFTS</A>
<LI><A HREF="#
HISTO_WRAP -- WRAPPER FOR HISTOGRAM THAT RETURNS THE BIN EDGES AND CENTERS">
HISTO_WRAP -- WRAPPER FOR HISTOGRAM THAT RETURNS THE BIN EDGES AND CENTERS</A>
<LI><A HREF="#LOMB -- EVALUATE LOMB PERIODOGRAM">
LOMB -- EVALUATE LOMB PERIODOGRAM</A>
<LI><A HREF="#LSCLEAN_CARL, DO A 'LEAST-SQUARES' 1D CLEAN.">
LSCLEAN_CARL, DO A 'LEAST-SQUARES' 1D CLEAN.</A>
<LI><A HREF="#STDCLEAN_CARL, DO A STANDARD 1D CLEAN. (A/LA DREHER ET AL PAPER)">
STDCLEAN_CARL, DO A STANDARD 1D CLEAN. (A/LA DREHER ET AL PAPER)</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="CLEAN_SP">
<H2>CLEAN_SP</H2></A>
<A HREF="#CUMFILTER -- FILTER BAD DATA USING CUMULATIVE DISTRIBUTION FUNCTION.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
PURPOSE: DO CLEAN ON DATA, USING PSF.

INPUTS:
XDATA, the x values of the data, a 1 d array of length M
DATA, the data stream, a 1 d array of length M
PSFFCN, a function name that evaluates the psf
GAIN, the loop gain
NITER, the nr of iterations to do 

OUTPUTS:
CLEAN_COMP, the list of clean components. A 2-d array of size
	2 X NITER. SECOND comp is amplitude actually subtracted, 
	FIRST is the position xdata.
	DATA_CLEAN, the current version of the cleaned data
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/sig_processing/clean_sp.pro)</STRONG><P>
<HR>
 
<A NAME="CUMFILTER -- FILTER BAD DATA USING CUMULATIVE DISTRIBUTION FUNCTION.">
<H2>CUMFILTER -- FILTER BAD DATA USING CUMULATIVE DISTRIBUTION FUNCTION.
</H2></A>
<A HREF="#CLEAN_SP">[Previous Routine]</A>
<A HREF="#DFT -- DIRECT FT USING IDL CONVENTION FOR FORWARD/REVERSE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
CUMFILTER -- filter bad data using cumulative distribution function.

PURPOSE: filter spikes from a distribution. uses the cumulative
distribution to define the effective sigma of the pdf so that outliers
don't artificially incrrease the sigmaa.

CALLING SEQUENCE:

	CUMFILTER, data, range, limit, indxgood, indxbad, countbad, $
	correct=correct, median=median

INPUTS:

	DATA, the vector of data to filter; can be output, too, if
CORRECT is set..

	RANGE, the number of elements to use for defining the non-noise
distribution. For now, set this equal to n_elements(data)/4

	LIMIT, the limit above which to define points as bad. For now,
set equal to 3. Phil tested this--the number should be bigger, but this
works reasonably well. IF LIMIT IS SET EQUAL TO OR LT ZERO, THEN THE
DEFAULT IS twice Chauvenet's criterion.

KEYWORDS:

	CORRECT: returns the corrected version of the data in place as
DATA. 

	MEDIAN: does running median filter before doing the
distribution. Set median when there are systematic departures from
flatness. In fact, you might as well ALWAYS set it.

	SIGMA_EMPIRICAL: the sigma derived empirically from the slope
of the cdf. If the input is a true Gaussian pdf, this sigma should 
equal that of the Gaussian.

OUTPUTS:

	INDXGOOD, the indx numbers of the good points.

	INDXBAD, the indx numbers of the bad points.

	COUNTBAD, the number of bad points found

METHOD:

	Loosely based on looking at the central portion of the
cumulative distribution, which is unaffeced by outliers. Use this to
define the sigma above which you discard points.

</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/sig_processing/cumfilter.pro)</STRONG><P>
<HR>
 
<A NAME="DFT -- DIRECT FT USING IDL CONVENTION FOR FORWARD/REVERSE">
<H2>DFT -- DIRECT FT USING IDL CONVENTION FOR FORWARD/REVERSE</H2></A>
<A HREF="#CUMFILTER -- FILTER BAD DATA USING CUMULATIVE DISTRIBUTION FUNCTION.
">[Previous Routine]</A>
<A HREF="#FSHIFT -- LIKE IDL'S SHIFT, BUT DOES FRACTIONAL SHIFTS
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
DFT -- DIRECT FT USing IDL CONVENTION FOR FORWARD/REVERSE

CALLING SEQUENCE: dft, inputx, inputy, outputx, outputy, [/inverse]

INPUTS:
	inputx, x-value at which input sig is sampled
	inputy, amplitude of input sig
	outputx, x-values at which you want the ft computed.
KEYWORD: 
	INVERSE. if set, does the idl inverse equivalent.
OUTPUTS
	outputy, ft of sig evaluated at outputx. complex.

TO TEST AND COMPARE WTIH THE FFT: see the attached 

	pro dfttst_2


IN PARTICULAR, NOTE HOW THE ORDER OF THE INPUT AND OUTPUT ARRAYS FOR THE
FFT MUST BE REARRANGED SO AS TO BE MONOTINICALLY INCREASING

MODS
	11nov04, carlh added check to see which method is faster in for loop.

</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/sig_processing/dft.pro)</STRONG><P>
<HR>
 
<A NAME="FSHIFT -- LIKE IDL'S SHIFT, BUT DOES FRACTIONAL SHIFTS">
<H2>FSHIFT -- LIKE IDL'S SHIFT, BUT DOES FRACTIONAL SHIFTS</H2></A>
<A HREF="#DFT -- DIRECT FT USING IDL CONVENTION FOR FORWARD/REVERSE
">[Previous Routine]</A>
<A HREF="#
HISTO_WRAP -- WRAPPER FOR HISTOGRAM THAT RETURNS THE BIN EDGES AND CENTERS
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fshift -- like idl's shift, but does fractional shifts
PURPOSE:
	LIKE IDL'S SHIFT, BUT WORKS FOR **FRACTIONAL** CHANNELS 
USING LINEAR INTERPOLATION.
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/sig_processing/fshift.pro)</STRONG><P>
<HR>
 
<A NAME="
HISTO_WRAP -- WRAPPER FOR HISTOGRAM THAT RETURNS THE BIN EDGES AND CENTERS">
<H2>HISTO_WRAP -- WRAPPER FOR HISTOGRAM THAT RETURNS THE BIN EDGES AND CENTERS
</H2></A>
<A HREF="#FSHIFT -- LIKE IDL'S SHIFT, BUT DOES FRACTIONAL SHIFTS
">[Previous Routine]</A>
<A HREF="#LOMB -- EVALUATE LOMB PERIODOGRAM">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
histo_wrap -- wrapper for histogram that returns the bin edges and centers

PURPOSE: wrapper for histogram that returns the bin edges and centers
note fixed inputs: max, min, nbins. 

CALLING SEQUENCE:
	histo_wrap, x, min, max, nbins, bin_edges, bin_cntrs, hx

INPUTS:
	X, the input array
	MIN, the min value in the histogram
	MAX, the max value in the histogram
	NBINS, the nr of bins in the histogram

OUTPUTS
	BIN_EDGES
	BIN_CNTRS
	HX, the histogram of the input array x
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/sig_processing/histo_wrap.pro)</STRONG><P>
<HR>
 
<A NAME="LOMB -- EVALUATE LOMB PERIODOGRAM">
<H2>LOMB -- EVALUATE LOMB PERIODOGRAM</H2></A>
<A HREF="#
HISTO_WRAP -- WRAPPER FOR HISTOGRAM THAT RETURNS THE BIN EDGES AND CENTERS
">[Previous Routine]</A>
<A HREF="#LSCLEAN_CARL, DO A 'LEAST-SQUARES' 1D CLEAN.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
lomb -- evaluate lomb periodogram

LOMB METHOD FOR PWR SPECTRUM
INPUTS:
	time, time at which input sig is sampled
	tsig, amplitude of input sig
	frqout, freqs at which you want the ft computed.
OUTPUTS
	Pftsig, PWR SPECT of sig evaluated at frqout. complex.
</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/sig_processing/lomb.pro)</STRONG><P>
<HR>
 
<A NAME="LSCLEAN_CARL, DO A 'LEAST-SQUARES' 1D CLEAN.">
<H2>LSCLEAN_CARL, DO A 'LEAST-SQUARES' 1D CLEAN.</H2></A>
<A HREF="#LOMB -- EVALUATE LOMB PERIODOGRAM">[Previous Routine]</A>
<A HREF="#STDCLEAN_CARL, DO A STANDARD 1D CLEAN. (A/LA DREHER ET AL PAPER)
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
LSCLEAN_CARL, DO A 'LEAST-SQUARES' 1D CLEAN.

CALLING SEQUENCE: lsclean_carl, inputx, inputy, gain, nitermax, $
	outputx, outputy, clean_comp, cleanoutputy, clean_iny, $
	plot_clean=plot_clean,  print_clean_comp=print_clean_comp

INPUTS:
WE DESCRIBE THE INPUTS AND OUTPUTS AS IF THE INPUTS ARE FREQ, OUTPUTS ARE TIME
INPUTX[], the input x values (e.g. freqs)
INPUTY[], the input y values (normally amplitude--real, not complex)
GAIN, the loop gain. should be high. should be adjusted inside for s/n of fit.
NITERMAX, the max nr of iterations, equal to nr of clean components that
	will be generated
OUTPUTX[] is the set of output x values (times) that will be searched for peaks

KEYWORDS:
PLOT_CLEAN. if set, plots each iteration and asks for key input to continue.
PRINT_CLEAN_COMP if set, print list of clean comp.

OUTPUTS:
OUTPUTY[] is the dirty y values correspondinig to OUTPUTX (complex)
CLEAN_COMP[ 2,NITERMAX], the list of clean components. clean_comp[0,*]
	is the X-value of the clean component (time), 
	clean_comp[1,*] are the [cos, sin] amplitudes.
CLEANOUTPUTY, the current version of the cleaned OUTPUTY values, equal to
	OUTPUTY minus the sum of the currently-existing clean components.
CLEAN_INY, the cleaned version of INPUTY obtained from the clean components
OUTPUTY_RECON, the output y values reconstructed from the clean components
       by adding them. Thus, this is a series of spikes that represent
       the complex clean components.

METHOD AND COMMENTS:
(1) calculate the digital fourier transorm (DFT) amplitude spectrum. 
that is, use INPUTX, CLEANY to calculate a straight dirty Y array.
then picks the max amplitude and remembers its X-value OUTPUTX_PEAK

(2) Does a ls fit: CLEANY = A + B COS( outputx_peak) + C SIN( outputx_peak)

(3) Sets clean_comp[ 0,nr]=outputx_peak ; clean_comp[ 1,nr]= complexarr( B,C)

(4) Loop back to (1) and repeat until done.

NOTE: to calculate values of cleaned input signal CLEAN_INY 
	for any input x value XV (even one that wasn't in the original array):

clean_iny= fltarr( n_elements( XV))
FOR NR= 0, NITERMAX-1 DO BEGIN
coeffs= [ 0., float( clean_comp[ 1, nr]), imaginary( clean_comp[ 1,nr])]
poly_ft_eval, XV, 0, coeffs, float( clean_comp[ 0,nr]), $
        yeval, yeval_poly, yeval_fourier
clean_iny= clean_iny+ yeval_fourier
ENDFOR

</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/sig_processing/lsclean_carl.pro)</STRONG><P>
<HR>
 
<A NAME="STDCLEAN_CARL, DO A STANDARD 1D CLEAN. (A/LA DREHER ET AL PAPER)">
<H2>STDCLEAN_CARL, DO A STANDARD 1D CLEAN. (A/LA DREHER ET AL PAPER)</H2></A>
<A HREF="#LSCLEAN_CARL, DO A 'LEAST-SQUARES' 1D CLEAN.">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
STDCLEAN_CARL, DO A STANDARD 1D CLEAN. (a/la dreher et al paper)

CALLING SEQUENCE: stdclean_carl, inputx, inputy, gain, nitermax, $
	outputx, outputy, clean_comp, cleanoutputy, clean_iny, $
	plot_clean=plot_clean,  print_clean_comp=print_clean_comp

INPUTS:
WE DESCRIBE THE INPUTS AND OUTPUTS AS IF THE INPUTS ARE FREQ, OUTPUTS ARE TIME
INPUTX[], the input x values (e.g. freqs)
INPUTY[], the input y values (normally amplitude--real, not complex)
GAIN, the loop gain. try 0.3??
NITERMAX, the max nr of iterations, equal to nr of clean components that
	will be generated
OUTPUTX[] is the set of output x values (times) that will be searched for peaks
	************ IMPORTANT ******************
	OUTPUTX MUST RANGE FROM 0 TO +TMAX WITH UNIFORM STEP SIZE.

KEYWORDS:
PLOT_CLEAN. if set, plots each iteration and asks for key input to continue.
PRINT_CLEAN_COMP if set, print list of clean comp.

OUTPUTS:
OUTPUTY[] the straight DFT-calculated (dirty) y values correspondinig to OUTPUTX,
	normally known as the 'dirty output' 
CLEAN_COMP[ 2,NITERMAX], the list of clean components. clean_comp[0,*]
	is the OUTPUTX-value of the clean component (time), 
	clean_comp[1,*] are the [cos, sin] amplitudes.
CLEANOUTPUTY, the current version of the cleaned OUTPUTY values, equal to
	OUTPUTY minus the sum of the currently-existing clean components.
CLEAN_INY, the version of INPUTY calculated from the clean components
OUTPUTY_RECON, the output y values reconstructed from the clean components
	by adding them. Thus, this is a series of spikes that represent 
	the complex clean components.

METHOD AND COMMENTS:

CLEAN_COMP are defined only for positive outputx.

NOTE: to calculate values of cleaned input signal CLEAN_INY 
	for any input x value XV (even one that wasn't in the original array):

clean_iny= fltarr( n_elements( XV))
FOR NR= 0, NITERMAX-1 DO BEGIN
coeffs= [ 0., float( clean_comp[ 1, nr]), imaginary( clean_comp[ 1,nr])]
poly_ft_eval, XV, 0, coeffs, float( clean_comp[ 0,nr]), $
        yeval, yeval_poly, yeval_fourier
clean_iny= clean_iny+ yeval_fourier
ENDFOR

</PRE><P>
<STRONG>(See /dzd2/heiles/idl/gen/sig_processing/stdclean_carl.pro)</STRONG><P>
<HR>
 
</body>
</html>
